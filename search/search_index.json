{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udf8d Mulang A universal, multi-language, multi-paradigm code analyzer Mulang is a tool for analysing source code, which is built on top of five main components: an Abstract Semantic Tree , an intermediate language which allows to express the semantic - as opposed to syntatic - structure of a multi-paradigm program; a set of more than 90 inspections for querying code querying code either explicitly - expectations - or implicitlt - smells . an Expectations Definition Language (EDL) , a language for defining custom expectations a command line tool for analysing both source code in many languages and Mulang's AST. This tool is distributed as both a linux-amd64 binary and a JavaScript package. See downloads section . higher level interfaces in ruby and javascript that are easier to use and provides some additional capabilities like expectations parsing and automatic internationalized humanization. Supported languages Mulang can work with many different programming languages. it natively supports: C Haskell Java JavaScript (ES6) Python (2 and 3) Prolog In addition, through external tools, it offers support for the following languages: Ruby, using mulang-ruby PHP, using mulang-php Gobstones, using gs-weblang-cli Sratch, using mulang-scratch If you want to use it with a different language, you will have to: either add explicit support in this repo - we love Pull Requests :heart: -, or translate your language into one of the natively supported ones, or translate your language to the Mulang JSON AST Quick start The following section uses the ruby interface for demonstration purposes. However, you also can run all the examples either using the comand line tool , or the javascript interface. The javascript version is also available as a ruby gem , suitable for Rails integration Better than explaining what Mulang is, let's see what it can do for you. Inspections Let's suppose we have the following JS code... let aPlace = buenosAires; let aBird = {position: aPlace, weight: 20}; ...and we want to recognize some code patterns on it. We will first load the expression into Mulang: require mulang code = Mulang::Code.native JavaScript , let aPlace = buenosAires; let aBird = {position: aPlace, weight: 20}; Now we want to know if the code expression uses - that is, contains any reference to - a given identifier . Such identifier could be a variable, function, or anything that has a name: code.expect 'Uses:buenosAires' = true # because of the reference in `...aPlace = buenosAires...` code.expect 'Uses:rosario' = false # no reference to the identifier `rosario` is found on the code Uses:buenosAires is our first inspection : a function that takes a Mulang AST and answers a boolean question about it. That seems easy, but just in case you are wondering: no, Mulang doesn't perform a string.contains or something like that :stuck_out_tongue: : code.expect 'Uses:BuenosAires' = false # no reference to the identifier `buenos` is found on the code Contexts So let's ask something more interesting - does aPlace use the identifier buenosAires ? code.expect 'aPlace', 'Uses:buenosAires' = true # again, because of the the reference in `...aPlace = buenosAires...` code.expect 'aPlace', 'Uses:aBird' = false # because `...aPlace = buenosAires...` does not reference `aBird`... Here we have contextualized the inspection, so it runs only within the contexts of the given binding. Let's tray again: does \"aPlace\" use rosario ? And what about the object aBird ? Does it use aPlace or rosario ? code.expect aPlace , Uses:rosario = false code.expect aBird , Uses:aPlace = true code.expect aBird , Uses:buenosAires = true Oh, wait! Is this a bug? Nope. Expectations are transitive by default: aBird uses aPlace , and aPlace uses buenosAires in turn, which means that aBird actually uses buenosAires . If you don't want that behaviour you can turn it off: code.expect Intransitive:aBird , Uses:buenosAires = false Contexts can be nested, too: for example, if you want to know whether aBird.position uses aPlace - ignoring that weight attribute: code.expect aBird.position , Uses:aPlace = true code.expect aBird.weight , Uses:aPlace = false Inspections do not only allow you to consult usages. They can tell you much more things. See the supported inspections list . Predicates Many inspections support an identifier predicate , that is, a matcher for the identifier. For example, does the former piece of code declare any attribute? code.expect 'DeclaresAttribute:*' = true code.expect 'DeclaresAttribute' # shorter version = true Does it declare an attribute like eight ? code.expect DeclaresAttribute:~eight = true Notice: like in Mulang means that it contains that case-insensitive substring Finally, does aBird declares an attribute that is not named weight ? code.expect DeclaresAttribute:^weight = true # because it also declares position Matchers Finally, you can provide a matcher to many of the available expectations, that allows to match specific parts of code with some patterns. code.expect 'DeclaresAttribute:WithNumber:20' = true # because weight is initialized with that value code.expect 'DeclaresAttribute:WithNumber:21' = false code.expect 'DeclaresAttribute:position:WithNonliteral' = true # because position is initialized with a non-literal value code.expect 'DeclaresAttribute:WithLiteral' = true # because weight is initialized with a literal value code.expect 'DeclaresAttribute:WithNil' = false # because no attribute is initialied with null The complete list of supported matchers is the following: WithFalse WithLiteral WithLogic WithMath WithNil WithNonliteral WithTrue WithChar:'value' WithSymbol:value WithNumber:value WithString:\"value\" Contributors Franco Bulgarelli @flbulgarelli @ Mumuki Julian Berbel Alt @julian-berbel @ Mumuki Federico Lochbaum @FedeLochbaum @ UNQ Lucas Traverso @ludat @ 10Pines Federico Scarpa @fedescarpa @ Mumuki","title":"Home"},{"location":"#mulang","text":"A universal, multi-language, multi-paradigm code analyzer Mulang is a tool for analysing source code, which is built on top of five main components: an Abstract Semantic Tree , an intermediate language which allows to express the semantic - as opposed to syntatic - structure of a multi-paradigm program; a set of more than 90 inspections for querying code querying code either explicitly - expectations - or implicitlt - smells . an Expectations Definition Language (EDL) , a language for defining custom expectations a command line tool for analysing both source code in many languages and Mulang's AST. This tool is distributed as both a linux-amd64 binary and a JavaScript package. See downloads section . higher level interfaces in ruby and javascript that are easier to use and provides some additional capabilities like expectations parsing and automatic internationalized humanization.","title":"\ud83c\udf8d Mulang"},{"location":"#supported-languages","text":"Mulang can work with many different programming languages. it natively supports: C Haskell Java JavaScript (ES6) Python (2 and 3) Prolog In addition, through external tools, it offers support for the following languages: Ruby, using mulang-ruby PHP, using mulang-php Gobstones, using gs-weblang-cli Sratch, using mulang-scratch If you want to use it with a different language, you will have to: either add explicit support in this repo - we love Pull Requests :heart: -, or translate your language into one of the natively supported ones, or translate your language to the Mulang JSON AST","title":"Supported languages"},{"location":"#quick-start","text":"The following section uses the ruby interface for demonstration purposes. However, you also can run all the examples either using the comand line tool , or the javascript interface. The javascript version is also available as a ruby gem , suitable for Rails integration Better than explaining what Mulang is, let's see what it can do for you.","title":"Quick start"},{"location":"#inspections","text":"Let's suppose we have the following JS code... let aPlace = buenosAires; let aBird = {position: aPlace, weight: 20}; ...and we want to recognize some code patterns on it. We will first load the expression into Mulang: require mulang code = Mulang::Code.native JavaScript , let aPlace = buenosAires; let aBird = {position: aPlace, weight: 20}; Now we want to know if the code expression uses - that is, contains any reference to - a given identifier . Such identifier could be a variable, function, or anything that has a name: code.expect 'Uses:buenosAires' = true # because of the reference in `...aPlace = buenosAires...` code.expect 'Uses:rosario' = false # no reference to the identifier `rosario` is found on the code Uses:buenosAires is our first inspection : a function that takes a Mulang AST and answers a boolean question about it. That seems easy, but just in case you are wondering: no, Mulang doesn't perform a string.contains or something like that :stuck_out_tongue: : code.expect 'Uses:BuenosAires' = false # no reference to the identifier `buenos` is found on the code","title":"Inspections"},{"location":"#contexts","text":"So let's ask something more interesting - does aPlace use the identifier buenosAires ? code.expect 'aPlace', 'Uses:buenosAires' = true # again, because of the the reference in `...aPlace = buenosAires...` code.expect 'aPlace', 'Uses:aBird' = false # because `...aPlace = buenosAires...` does not reference `aBird`... Here we have contextualized the inspection, so it runs only within the contexts of the given binding. Let's tray again: does \"aPlace\" use rosario ? And what about the object aBird ? Does it use aPlace or rosario ? code.expect aPlace , Uses:rosario = false code.expect aBird , Uses:aPlace = true code.expect aBird , Uses:buenosAires = true Oh, wait! Is this a bug? Nope. Expectations are transitive by default: aBird uses aPlace , and aPlace uses buenosAires in turn, which means that aBird actually uses buenosAires . If you don't want that behaviour you can turn it off: code.expect Intransitive:aBird , Uses:buenosAires = false Contexts can be nested, too: for example, if you want to know whether aBird.position uses aPlace - ignoring that weight attribute: code.expect aBird.position , Uses:aPlace = true code.expect aBird.weight , Uses:aPlace = false Inspections do not only allow you to consult usages. They can tell you much more things. See the supported inspections list .","title":"Contexts"},{"location":"#predicates","text":"Many inspections support an identifier predicate , that is, a matcher for the identifier. For example, does the former piece of code declare any attribute? code.expect 'DeclaresAttribute:*' = true code.expect 'DeclaresAttribute' # shorter version = true Does it declare an attribute like eight ? code.expect DeclaresAttribute:~eight = true Notice: like in Mulang means that it contains that case-insensitive substring Finally, does aBird declares an attribute that is not named weight ? code.expect DeclaresAttribute:^weight = true # because it also declares position","title":"Predicates"},{"location":"#matchers","text":"Finally, you can provide a matcher to many of the available expectations, that allows to match specific parts of code with some patterns. code.expect 'DeclaresAttribute:WithNumber:20' = true # because weight is initialized with that value code.expect 'DeclaresAttribute:WithNumber:21' = false code.expect 'DeclaresAttribute:position:WithNonliteral' = true # because position is initialized with a non-literal value code.expect 'DeclaresAttribute:WithLiteral' = true # because weight is initialized with a literal value code.expect 'DeclaresAttribute:WithNil' = false # because no attribute is initialied with null The complete list of supported matchers is the following: WithFalse WithLiteral WithLogic WithMath WithNil WithNonliteral WithTrue WithChar:'value' WithSymbol:value WithNumber:value WithString:\"value\"","title":"Matchers"},{"location":"#contributors","text":"Franco Bulgarelli @flbulgarelli @ Mumuki Julian Berbel Alt @julian-berbel @ Mumuki Federico Lochbaum @FedeLochbaum @ UNQ Lucas Traverso @ludat @ 10Pines Federico Scarpa @fedescarpa @ Mumuki","title":"Contributors"},{"location":"astspec/","text":"Mulang AST spec In this section, we will get into the technical details of the Mulang AST. It is built around 5 core elements: Expressions Patterns Types Equations Generators All the AST elements fall within any of these 5 categories. Expressions Expressions are the most important element kind, since contain most of the information of a Mulang program and are always the root element of it. In fact, this implementation does not contain an AST or Program datatype - it is instead types as Expression . Expression in Mulang model what you will normally spec in a language as a expression, that is something that holds a value and a type. For example, 4 + 5 and [2, 3].toString() are typical expresion. However, Mulang extends this concept to most kind of elements in a program, regadless they are have an actual value in the original language. For example, class declarations and while statements are modeled as expression, although in many languages they aren't. As a rule of thumb if something is or can be represented as an statement, declararion or expression, the it is modeled as Expression in Mulang AST. Record A Record represents a record, data or struct declaration, as found in most procedural and functional languages, like the C-like struct declaration Syntax (Record Identifier) C Example struct point { int x; int y; } (Record point ) Caveats Currently, the Record expression does not hold information about the record contents. TypeAlias , TypeSignature and TypeCast Mulang AST support for type analysis is quite limited, and it is mostly focused on expressions and declarations analysis. However, for sake of completeness and in order to provide some limited type-information in Mulang AST, TypeAlias , TypeSignature and TypeCast expressions are provided. See types section for more details. EntryPoint Entry point with its name and body. It typically correspond to C-like main procedures, or program declarations. Syntax (EntryPoint Identifier Expression) Java Example public static main(String[] args) {} (EntryPoint main MuNil) Function Functional / Imperative programming function declaration. It is is composed by an identifier and one or more equations Syntax (Function Identifier [Equation]) C Example int foo (int bar) { return bar; } Sequence [ TypeSignature foo (ParameterizedType [ int ] int []), Function foo [ Equation [VariablePattern bar ] (UnguardedBody (Return (Reference bar )))]] Python Example def foo(): return 1 (Function foo [ (Equation [] (UnguardedBody (Return (MuNumber 1.0))))]) def foo(bar): return bar (Function foo [ (Equation [VariablePattern bar ] (UnguardedBody (Return (Reference bar ))))]) Procedure Imperative programming procedure declaration. It is composed by an identifier and one or more equations Syntax (Procedure Identifier [Equation]) Method Object oriented programming method declaration. It is composed by an identifier and one or more equations Syntax (Method Identifier [Equation]) Ruby Example class Bird def sing! puts singing in the dead of night end end (Class Bird Nothing (Method sing! [ (Equation [] (UnguardedBody (Print (MuString singing in the dead of night ))))])) Java Example public class Bird { public void sing() { System.out.println( singing in the dead of night ); } } (Class Bird Nothing (Method sing [ (Equation [] (UnguardedBody (Print (MuString singing in the dead of night ))))])) PrimitiveMethod Declaration of custom primitive operators - also known as operator overriding. See primitive operators Syntax (PrimitiveMethod Operator [Equation]) Ruby Example def ==(other) end def hash end (Sequence [ (PrimitiveMethod Equal (Equation [VariablePatten other ] (UnguardedBody MuNil))), (PrimitiveMethod Hash (Equation [] (UnguardedBody MuNil)))]) Variable Generic variable declaration, composed by an identifier and an initializer Syntax (Variable Identifier Expression) C Example int a = 10; (Sequence [ TypeSignature a (SimpleType int []), Variable a (MuNumber 10.0)]) JavaScript Example let x = 1; (Variable x (MuNumber 1)) Assignment Syntax (Assignment Identifier Expression) C Example m = 3.4; (Assignment m (MuNumber 3.4)) Ruby Example m = 3.4 (Assignment m (MuNumber 3.4)) Attribute Object oriented programming attribute declaration, composed by an identifier and an initializer Syntax (Attribute Identifier Expression) Java Example public class Foo { private int bar = 4; } (Class Foo Nothing (Sequence [ (VariableSignature bar int []), (Attribute bar (MuNumber 4))])) Object Object oriented programming global, named object declaration, like Scala's object , composed by a name and a body. Syntax (Object Identifier Expression) Example Class Object oriented programming global, class declaration, composed by a name, an optional superclass and a body Syntax (Class Identifier (Maybe Identifier) Expression) Ruby Example class Bird Animal end (Class Bird (Just Animal ) MuNil) Java Examples public class Bird extends Animal {} (Class Bird (Just Animal ) MuNil) Enumeration Imperative named enumeration of values Syntax (Enumeration Identifier [Identifier]) Java Example public enum Fuzzy { YES, NO, MAYBE } (Enumeration Fuzzy [ YES , NO , MAYBE ]) Interface Object oriented programming global interface or contract declaration, composed by a name, superinterfaces and a body. Syntax (Interface Identifier [Identifier] Expression) Java Example public interface Foo extends Bar, Baz { void foo(); } (Interface Foo [ Bar , Baz ] (TypeSignature foo [] void )) Rule Logic programming declaration of rule fact, composed by the rule name, rule arguments, and rule body Syntax (Rule Identifier [Pattern] [Expression]) Example baz(bar) :- foo(bar) (Rule baz [(LiteralPattern bar )] [(Exist foo [(LiteralPattern bar )])]) Fact Logic programming declaration of a fact , composed by the fact name and fact arguments Syntax (Fact Identifier [Pattern]) Example foo(bar). (Fact foo [(LiteralPattern bar )]) Exist Logic programming existential cuantification / consult Syntax (Exist Identifier [Pattern]) Example Not Logic programming negation Syntax (Not Expression) Findall Logic programming findall Syntax (Findall Expression Expression Expression) Forall Logic programming universal cuantification Syntax (Forall Expression Expression) Reference Generic variable Syntax (Reference Identifier) C Example int x = 4; x (Sequence [ TypeSignature x (SimpleType int []), Variable x (MuNumber 4.0), Reference x ]) JavaScript Example const x = 4; x (Sequence [ (Variable x (MuNumber 4.0), (Reference x ))]) Application Generic, non-curried application of a function or procedure, composed by the applied element itself, and the application arguments Syntax (Application Expression [Expression]) Example Send Object oriented programming message send, composed by the reciever, selector and arguments Syntax (Send Expression Expression [Expression]) Ruby Example 1 + 5 (Send (MuNumber 1) (Reference + ) [MuNumber 5]) New Object oriented instantiation, composed by the class reference and instantiation arguments Syntax (New Identifier [Expression]) Implement Object oriented instantiation, interface implementation Syntax (Implement Identifier) Include Object oriented instantiation, mixin inclusion Syntax (Include Identifier) If Syntax (If Expression Expression Expression) Lambda Syntax (Lambda [Pattern] Expression) Return Syntax (Return Expression) While Imperative programming conditional repetition control structure, composed by a condition and a body Syntax (While Expression Expression) Repeat Imperative programming fixed repetition control structure, composed by a repetition count expression, and a body Syntax (Repeat Expression Expression) Match Syntax (Match Expression [Equation]) Switch Generic switch expression, composed by the value to switch on, a list of cases and the default Syntax (Switch Expression [(Expression, Expression)] Expression) Try Generic try expression, composed by a body, a list of exception-handling patterns and statments, and a finally expression Syntax (Try Expression [(Pattern, Expression)] Expression) Raise Generic raise expression, like a throw or raise statament, composed by the raised expression Syntax (Raise Expression) JavaScript Example throw 'abc'; (Raise (MuString abc )) Print Generic print expression Syntax (Print Expression) Ruby Example puts Hello World (Print (MuString Hello World )) For For s generalices the concept of comprehensions an indexed repetition. With a For you can build: ForComprehension , when the for expression is a yield. Scala's for comprehensions, Erlang's and Haskell's list comprehensions, and Haskell's do-syntaxt map to it. ForEach , when the for expression is not a yield. Java's for: , or some scenarios of scala's for map to it. Syntax (For [Statment] Expression) Haskell Example m = [ f x | x - [1, 2, 3, 4] ] (Variable m (For [(Generator (VariablePattern x ) (MuList [(MuNumber 1), (MuNumber 2), (MuNumber 3), (MuNumber 4)]))] (Yield (Application (Reference f ) [(Reference x )])))) Java Example for (Integer i : ints) { System.out.println(i); } (For [(Generator (VariablePattern i ) (Reference ints ))] (Print (Reference i ))) ForLoop ForLoop represents the imperative programming c-style for loop: Syntax (ForLoop Expression Expression Expression Expression) C Example for (int i = 0; i 10; i++) { foo(i); } (ForLoop (Sequence [ TypeSignature i (SimpleType int []), Variable i (MuNumber 0.0)]) (Application (Primitive LessThan) [Reference i ,MuNumber 10.0]) (Assignment i (Application (Primitive Plus) [Reference i ,MuNumber 1.0])) (Application (Reference foo ) [Reference i ]))) JavaScript Example for (let i = 0; i 10; i++) { console.log(i); } (ForLoop (Variable i (MuNumber 0.0)) (Application (Reference ) [Reference i ,MuNumber 10.0]) (Assignment i (Application (Reference + ) [Reference i ,MuNumber 1.0])) (Send (Reference console ) (Reference log ) [Reference i ])) Sequence Generic sequence of statements Syntax (Sequence [Expression]) Other Unrecognized expression, with optional description and body Syntax (Other (Maybe Code) (Maybe Expression)) Arrow Generic arrow - AKA pair or entry - that is typically used to build dictionaries. It corresponds to ruby's, perl's and php's = operator, or ruby's and javascript's : operator Syntax (Arrow Expression Expression) See MuDict for more details Self Object oriented self-reference, like C-like this and Smalltalk-derived self Syntax (Self) None Used as a placeholder for empty bodies. Syntax (None) Break Used to break out of flow structure Syntax (Break Expression) Continue Used to jump over to next flow structure step Syntax (Continue Expression) MuNil Generic nothing value literal - nil , null , () or unit . Syntax (MuNil) MuDict Generic dictionary - AKA hash, table or map - value literal. Its expressions are normally a sequence of Arrow s Syntax (MuDict Expression) Python Example {'foo': 1} (MuDict (Arrow (MuString foo ) (MuNumber 1))) {'foo': 1, 'bar': 2} (MuDict (Sequence [ (Arrow (MuString foo ) (MuNumber 1)), (Arrow (MuString bar ) (MuNumber 2))]) MuObject Object oriented unnamed object literal Syntax (MuObject Expression) JavaScript Example {} {foo: 1} {foo: 1, bar: 2} (MuObject MuNil) (MuObject (Attribute foo (MuNumber 1))) (MuObject (Sequence [ (Attribute foo (MuNumber 1)), (Attribute bar (MuNumber 2))])) MuNumber , MuBool , MuString , MuSymbol and MuChar Generic number, boolean, string, symbol (atoms) and char literals Syntax (MuNumber Double) (MuBool Bool) (MuString String) (MuSymbol String) (MuChar Char) Ruby Example 1 true hello :hello (Sequence [ (MuNumber 1), (MuBool True), (MuString hello ), (MuSymbol hello )]) MuTuple and MuList They represent tuples - generic non-uniform fixed-size collection of elements - and lists - generic uniform variable-size collection of elements. Lists typically map to arrays, lists or sequence-like structures. Syntax (MuTuple [Expression]) (MuList [Expression]) TestGroup , Test and Assert Generic test framework expressions used to represent unit tests. TestGroup represents a test grouping expression such as describe , context , etc Test represents a test expression such as it , etc Assert represents a test's assertion, such as assert.equals(...) , etc. It receives a boolean that represents whether the assertion is negated or not. Syntax (TestGroup Expression Expression) (Test Expression Expression) (Assert Bool Assertion) Javascript Example describe( succ , function() { it( succ of 3 is 4 , function() { assert.equals(succ(3), 4) }) }) TestGroup (MuString succ ) (Test (MuString succ of 3 is 4 ) (Assert False (Equality (Application (Reference succ ) [MuNumber 3.0]) (MuNumber 4.0)))) Python Example class TestGroup(unittest.TestCase): def test_succ_of_3_is_4(): self.assertEqual(succ(3), 4) TestGroup (MuString TestGroup ) (Test (MuString test_succ_of_3_is_4 ) (Assert False (Equality (Application (Reference succ ) [MuNumber 3.0]) (MuNumber 4.0)))) Assertion Assertions used within tests to dynamically ascertain the code's validity. An assertion can be one of: * Truth : Assert the truthfulness of a given expression. * Equality : Assert the equality of two given expressions. * Failure : Assert a given expression fails with a given error. Syntax (Truth Expression) (Equality Expression Expression) (Failure Expression Expression) Javascript Examples assert(true) Assert False (Truth (MuBool True)) assert.equals(3, 3) Assert False (Equality (MuNumber 3) (MuNumber 3)) assert.throws(function() { throw('error!') }, 'error!') Assert False (Failure (Lambda [] (Raise (MuString error! ))) (MuString error! )) Patterns Patterns are the second most important element of Mulang AST. They represent things that don't hold a value, but are instead used to match values, like patterns in imperative case or switch statements, functional pattern matching in match or case expressions, or exception matching in try-catch or begin-rescue -like statements in object oriented languages. VariablePattern Variable pattern represent a variable match. It corresponds to normal formal parameters in precedural languages, and to simple pattern matching against a free identifier. Syntax (VariablePattern String) JavaScript Example function foo(x, y) { } (Function foo [(Equation [(VariablePattern x ), (VariablePattern y )] (UnguardedBody MuNil))]) LiteralPattern Literal constant pattern Syntax (LiteralPattern String) Example InfixApplicationPattern Infix application pattern like 4:X Syntax (InfixApplicationPattern Pattern String Pattern) Caveats InfixApplicationPattern exposes the underying syntax and will be deprecated. ApplicationPattern prefix application pattern like f _ Syntax (ApplicationPattern String [Pattern]) Example TuplePattern tuple pattern like (3, _) Syntax (TuplePattern [Pattern]) Example ListPattern list pattern like [x, y, _] Syntax (ListPattern [Pattern]) Example FunctorPattern Prolog-like functor pattern, like f(X, 6) . Syntax (FunctorPattern Identifier [Pattern]) Example AsPattern Syntax (AsPattern Identifier Pattern) Example TypePattern A type pattern, like in exception handling constructs in most object-oriented languages Syntax (TypePattern Identifier) Example WildcardPattern Wildcard pattern, typically _ in functional an logic programming languages. Syntax (WildcardPattern) UnionPattern Syntax (UnionPattern [Pattern]) OtherPattern Other unrecognized pattern Syntax (OtherPattern) Primitive Operators Primitive operators represent low-level language operations that are well known and common to most languages, usually in the fashion of operators. They are natively supported by mulang. Absolute : numeric abs -like absolute operator AllSatisfy : collection all -like / every -like operator And : -like and operator AnySatisfy : collection any -like / some -like operator BackwardComposition : (g f)(x) = (g . f)(x) = g(f(x)) operator BitwiseAnd : bit-level -like and operator BitwiseLeftShift : bit-level left -like shift operator BitwiseOr : bit-level | -like or operator BitwiseRightShift : bit-level right -like shift operator BitwiseXor : bit-level ^ -like xor operator Ceil : numeric ceil -like ceiling operator Collect : collection map -like operator Count : collection count -like operator Detect : collection find -like search operator DetectMax : collection max -like maximum operator DetectMin : collection min -like minumum operator Divide : numeric / operator Equal : === -like equal operator Flatten : collection flatten -like operator Floor : numeric ceil -like floor operator ForwardComposition : (f g)(x) = (g . f)(x) = g(f(x)) operator Gather : collection flatmap -like operator GetAt : collection [] -like operator GreatherOrEqualThan : = operator GreatherThan : operator Hash : hashcode operator Inject : collection reduce -like / fold -like operator LessOrEqualThan : = operator LessThan : operator Max : max -like maximum value binary operator Min : min -like minimum value binary operator Minus : numeric - operator Modulo : numeric %-like modulo operator Multiply : numeric * operator Negation : ! -like not operator NotEqual : !== -like distinct operator NotSame : not reference-identical operator NotSimilar : not equal-ignoring-type operator Or : || -like or operator Otherwise : guard's otherwise operator Plus : numeric + operator Push : collection insertAtEnd -like operator Round : numeric round -like round operator Same : reference-identical operator Select : collection filter -like operator SetAt : collection []= -like operator Similar : equal-ignoring-type operator Size : collection length -like size operator Types When processing statically-typed languages, all type-information - regardless we are typing a function, a variable or a class - is represented with the Type ADT, can be one of: SimpleType : composed by a type identifier and zero or type more constraints ParameterizedType : composed by input type parmaters, an output type, and type constratins ConstrainedType : composed by just type constraints. OtherType : an unrecognized type Type s can be introduced in the Mulang AST using the following elements: TypeAlias A TypeAlias represents a synonym for a type, like the type declaration in Haskell and Scala or C's typedef . It is a typical statically typed functional programming feature. Syntax (TypeAlias Identifier Identifier) Haskell Example type Point = (Int, Int) (TypeAlias Point (Int, Int) ) TypeSignature A TypeSignature represents an explicit type annotation for a computation, variable or module, as you can find in Java or Haskell. Syntax (TypeSignature Identifier Type) Haskell Examples Simple types: name :: String (TypeSignature name (SimpleType String [])) Simple types and constraints: f :: Num a = a ```` ```haskell (TypeSignature f (SimpleType a [ Num a ])) Parameterized types: elem :: (Eq a, Foldable t) = a - t a - Bool ```` ```haskell (TypeSignature elem (ParameterizedType [ a , t a ] Bool [ Eq a , Foldable t ])) Java Examples In Java, as in most typed C-like languages, type signature and variable declarations are bound. This means that, for example, a local variable declaration will produce both a TypeSignature and a Variable expression. Variable and attribute types: String name; (TypeSignature name (SimpleType String [])) Method types: String f() { return null; } (TypeSignature f (ParameterizedType [] String [])) Method types with type parameters: A A f() { return null; } (TypeSignature f (ParameterizedType [] A [ A ])) Method types with type parameters and constraints: A super B void f(A a) {} (TypeSignature f (ParameterizedType [ A ] void [ A super B ])) Class or interfaces types: class A B extends C, D extends C { } (TypeSignature A (ConstrainedType [ B extends C , D extends C ])) TypeCast A TypeCast represent explictly giving a type to an expression which may have static or dynamic impact on the program. It is aimed to represent type-casts in c-like languages and inline type signatures in functional languages. Syntax (TypeCast Expression Type) Haskell Examples Simple types: ... = 4 :: Num a = a (TypeCast (MuNumber 4) (SimpleType a [ Num a ])) Java Examples Variable and attribute types: (Integer) 4; (TypeCast (MuNumber 4) (SimpleType Integer [])) (Option Integer ) something; (TypeCast (Reference something ) (SimpleType Option Integer [])) Caveats The type constraints refer to type-constrained parametrizations that the cast introduces, and not any other kind of constraints the cast uses. That is whay the following Java code: (Num A ) something; produces: (TypeCast (Reference something ) (SimpleType Num A [])) instead of: (TypeCast (Reference something ) (SimpleType Num [ A ]))","title":"AST Spec"},{"location":"astspec/#mulang-ast-spec","text":"In this section, we will get into the technical details of the Mulang AST. It is built around 5 core elements: Expressions Patterns Types Equations Generators All the AST elements fall within any of these 5 categories.","title":"Mulang AST spec"},{"location":"astspec/#expressions","text":"Expressions are the most important element kind, since contain most of the information of a Mulang program and are always the root element of it. In fact, this implementation does not contain an AST or Program datatype - it is instead types as Expression . Expression in Mulang model what you will normally spec in a language as a expression, that is something that holds a value and a type. For example, 4 + 5 and [2, 3].toString() are typical expresion. However, Mulang extends this concept to most kind of elements in a program, regadless they are have an actual value in the original language. For example, class declarations and while statements are modeled as expression, although in many languages they aren't. As a rule of thumb if something is or can be represented as an statement, declararion or expression, the it is modeled as Expression in Mulang AST.","title":"Expressions"},{"location":"astspec/#record","text":"A Record represents a record, data or struct declaration, as found in most procedural and functional languages, like the C-like struct declaration","title":"Record"},{"location":"astspec/#syntax","text":"(Record Identifier)","title":"Syntax"},{"location":"astspec/#c-example","text":"struct point { int x; int y; } (Record point )","title":"C Example"},{"location":"astspec/#caveats","text":"Currently, the Record expression does not hold information about the record contents.","title":"Caveats"},{"location":"astspec/#typealias-typesignature-and-typecast","text":"Mulang AST support for type analysis is quite limited, and it is mostly focused on expressions and declarations analysis. However, for sake of completeness and in order to provide some limited type-information in Mulang AST, TypeAlias , TypeSignature and TypeCast expressions are provided. See types section for more details.","title":"TypeAlias, TypeSignature and TypeCast"},{"location":"astspec/#entrypoint","text":"Entry point with its name and body. It typically correspond to C-like main procedures, or program declarations.","title":"EntryPoint"},{"location":"astspec/#syntax_1","text":"(EntryPoint Identifier Expression)","title":"Syntax"},{"location":"astspec/#java-example","text":"public static main(String[] args) {} (EntryPoint main MuNil)","title":"Java Example"},{"location":"astspec/#function","text":"Functional / Imperative programming function declaration. It is is composed by an identifier and one or more equations","title":"Function"},{"location":"astspec/#syntax_2","text":"(Function Identifier [Equation])","title":"Syntax"},{"location":"astspec/#c-example_1","text":"int foo (int bar) { return bar; } Sequence [ TypeSignature foo (ParameterizedType [ int ] int []), Function foo [ Equation [VariablePattern bar ] (UnguardedBody (Return (Reference bar )))]]","title":"C Example"},{"location":"astspec/#python-example","text":"def foo(): return 1 (Function foo [ (Equation [] (UnguardedBody (Return (MuNumber 1.0))))]) def foo(bar): return bar (Function foo [ (Equation [VariablePattern bar ] (UnguardedBody (Return (Reference bar ))))])","title":"Python Example"},{"location":"astspec/#procedure","text":"Imperative programming procedure declaration. It is composed by an identifier and one or more equations","title":"Procedure"},{"location":"astspec/#syntax_3","text":"(Procedure Identifier [Equation])","title":"Syntax"},{"location":"astspec/#method","text":"Object oriented programming method declaration. It is composed by an identifier and one or more equations","title":"Method"},{"location":"astspec/#syntax_4","text":"(Method Identifier [Equation])","title":"Syntax"},{"location":"astspec/#ruby-example","text":"class Bird def sing! puts singing in the dead of night end end (Class Bird Nothing (Method sing! [ (Equation [] (UnguardedBody (Print (MuString singing in the dead of night ))))]))","title":"Ruby Example"},{"location":"astspec/#java-example_1","text":"public class Bird { public void sing() { System.out.println( singing in the dead of night ); } } (Class Bird Nothing (Method sing [ (Equation [] (UnguardedBody (Print (MuString singing in the dead of night ))))]))","title":"Java Example"},{"location":"astspec/#primitivemethod","text":"Declaration of custom primitive operators - also known as operator overriding. See primitive operators","title":"PrimitiveMethod"},{"location":"astspec/#syntax_5","text":"(PrimitiveMethod Operator [Equation])","title":"Syntax"},{"location":"astspec/#ruby-example_1","text":"def ==(other) end def hash end (Sequence [ (PrimitiveMethod Equal (Equation [VariablePatten other ] (UnguardedBody MuNil))), (PrimitiveMethod Hash (Equation [] (UnguardedBody MuNil)))])","title":"Ruby Example"},{"location":"astspec/#variable","text":"Generic variable declaration, composed by an identifier and an initializer","title":"Variable"},{"location":"astspec/#syntax_6","text":"(Variable Identifier Expression)","title":"Syntax"},{"location":"astspec/#c-example_2","text":"int a = 10; (Sequence [ TypeSignature a (SimpleType int []), Variable a (MuNumber 10.0)])","title":"C Example"},{"location":"astspec/#javascript-example","text":"let x = 1; (Variable x (MuNumber 1))","title":"JavaScript Example"},{"location":"astspec/#assignment","text":"","title":"Assignment"},{"location":"astspec/#syntax_7","text":"(Assignment Identifier Expression)","title":"Syntax"},{"location":"astspec/#c-example_3","text":"m = 3.4; (Assignment m (MuNumber 3.4))","title":"C Example"},{"location":"astspec/#ruby-example_2","text":"m = 3.4 (Assignment m (MuNumber 3.4))","title":"Ruby Example"},{"location":"astspec/#attribute","text":"Object oriented programming attribute declaration, composed by an identifier and an initializer","title":"Attribute"},{"location":"astspec/#syntax_8","text":"(Attribute Identifier Expression)","title":"Syntax"},{"location":"astspec/#java-example_2","text":"public class Foo { private int bar = 4; } (Class Foo Nothing (Sequence [ (VariableSignature bar int []), (Attribute bar (MuNumber 4))]))","title":"Java Example"},{"location":"astspec/#object","text":"Object oriented programming global, named object declaration, like Scala's object , composed by a name and a body.","title":"Object"},{"location":"astspec/#syntax_9","text":"(Object Identifier Expression)","title":"Syntax"},{"location":"astspec/#example","text":"","title":"Example"},{"location":"astspec/#class","text":"Object oriented programming global, class declaration, composed by a name, an optional superclass and a body","title":"Class"},{"location":"astspec/#syntax_10","text":"(Class Identifier (Maybe Identifier) Expression)","title":"Syntax"},{"location":"astspec/#ruby-example_3","text":"class Bird Animal end (Class Bird (Just Animal ) MuNil)","title":"Ruby Example"},{"location":"astspec/#java-examples","text":"public class Bird extends Animal {} (Class Bird (Just Animal ) MuNil)","title":"Java Examples"},{"location":"astspec/#enumeration","text":"Imperative named enumeration of values","title":"Enumeration"},{"location":"astspec/#syntax_11","text":"(Enumeration Identifier [Identifier])","title":"Syntax"},{"location":"astspec/#java-example_3","text":"public enum Fuzzy { YES, NO, MAYBE } (Enumeration Fuzzy [ YES , NO , MAYBE ])","title":"Java Example"},{"location":"astspec/#interface","text":"Object oriented programming global interface or contract declaration, composed by a name, superinterfaces and a body.","title":"Interface"},{"location":"astspec/#syntax_12","text":"(Interface Identifier [Identifier] Expression)","title":"Syntax"},{"location":"astspec/#java-example_4","text":"public interface Foo extends Bar, Baz { void foo(); } (Interface Foo [ Bar , Baz ] (TypeSignature foo [] void ))","title":"Java Example"},{"location":"astspec/#rule","text":"Logic programming declaration of rule fact, composed by the rule name, rule arguments, and rule body","title":"Rule"},{"location":"astspec/#syntax_13","text":"(Rule Identifier [Pattern] [Expression])","title":"Syntax"},{"location":"astspec/#example_1","text":"baz(bar) :- foo(bar) (Rule baz [(LiteralPattern bar )] [(Exist foo [(LiteralPattern bar )])])","title":"Example"},{"location":"astspec/#fact","text":"Logic programming declaration of a fact , composed by the fact name and fact arguments","title":"Fact"},{"location":"astspec/#syntax_14","text":"(Fact Identifier [Pattern])","title":"Syntax"},{"location":"astspec/#example_2","text":"foo(bar). (Fact foo [(LiteralPattern bar )])","title":"Example"},{"location":"astspec/#exist","text":"Logic programming existential cuantification / consult","title":"Exist"},{"location":"astspec/#syntax_15","text":"(Exist Identifier [Pattern])","title":"Syntax"},{"location":"astspec/#example_3","text":"","title":"Example"},{"location":"astspec/#not","text":"Logic programming negation","title":"Not"},{"location":"astspec/#syntax_16","text":"(Not Expression)","title":"Syntax"},{"location":"astspec/#findall","text":"Logic programming findall","title":"Findall"},{"location":"astspec/#syntax_17","text":"(Findall Expression Expression Expression)","title":"Syntax"},{"location":"astspec/#forall","text":"Logic programming universal cuantification","title":"Forall"},{"location":"astspec/#syntax_18","text":"(Forall Expression Expression)","title":"Syntax"},{"location":"astspec/#reference","text":"Generic variable","title":"Reference"},{"location":"astspec/#syntax_19","text":"(Reference Identifier)","title":"Syntax"},{"location":"astspec/#c-example_4","text":"int x = 4; x (Sequence [ TypeSignature x (SimpleType int []), Variable x (MuNumber 4.0), Reference x ])","title":"C Example"},{"location":"astspec/#javascript-example_1","text":"const x = 4; x (Sequence [ (Variable x (MuNumber 4.0), (Reference x ))])","title":"JavaScript Example"},{"location":"astspec/#application","text":"Generic, non-curried application of a function or procedure, composed by the applied element itself, and the application arguments","title":"Application"},{"location":"astspec/#syntax_20","text":"(Application Expression [Expression])","title":"Syntax"},{"location":"astspec/#example_4","text":"","title":"Example"},{"location":"astspec/#send","text":"Object oriented programming message send, composed by the reciever, selector and arguments","title":"Send"},{"location":"astspec/#syntax_21","text":"(Send Expression Expression [Expression])","title":"Syntax"},{"location":"astspec/#ruby-example_4","text":"1 + 5 (Send (MuNumber 1) (Reference + ) [MuNumber 5])","title":"Ruby Example"},{"location":"astspec/#new","text":"Object oriented instantiation, composed by the class reference and instantiation arguments","title":"New"},{"location":"astspec/#syntax_22","text":"(New Identifier [Expression])","title":"Syntax"},{"location":"astspec/#implement","text":"Object oriented instantiation, interface implementation","title":"Implement"},{"location":"astspec/#syntax_23","text":"(Implement Identifier)","title":"Syntax"},{"location":"astspec/#include","text":"Object oriented instantiation, mixin inclusion","title":"Include"},{"location":"astspec/#syntax_24","text":"(Include Identifier)","title":"Syntax"},{"location":"astspec/#if","text":"","title":"If"},{"location":"astspec/#syntax_25","text":"(If Expression Expression Expression)","title":"Syntax"},{"location":"astspec/#lambda","text":"","title":"Lambda"},{"location":"astspec/#syntax_26","text":"(Lambda [Pattern] Expression)","title":"Syntax"},{"location":"astspec/#return","text":"","title":"Return"},{"location":"astspec/#syntax_27","text":"(Return Expression)","title":"Syntax"},{"location":"astspec/#while","text":"Imperative programming conditional repetition control structure, composed by a condition and a body","title":"While"},{"location":"astspec/#syntax_28","text":"(While Expression Expression)","title":"Syntax"},{"location":"astspec/#repeat","text":"Imperative programming fixed repetition control structure, composed by a repetition count expression, and a body","title":"Repeat"},{"location":"astspec/#syntax_29","text":"(Repeat Expression Expression)","title":"Syntax"},{"location":"astspec/#match","text":"","title":"Match"},{"location":"astspec/#syntax_30","text":"(Match Expression [Equation])","title":"Syntax"},{"location":"astspec/#switch","text":"Generic switch expression, composed by the value to switch on, a list of cases and the default","title":"Switch"},{"location":"astspec/#syntax_31","text":"(Switch Expression [(Expression, Expression)] Expression)","title":"Syntax"},{"location":"astspec/#try","text":"Generic try expression, composed by a body, a list of exception-handling patterns and statments, and a finally expression","title":"Try"},{"location":"astspec/#syntax_32","text":"(Try Expression [(Pattern, Expression)] Expression)","title":"Syntax"},{"location":"astspec/#raise","text":"Generic raise expression, like a throw or raise statament, composed by the raised expression","title":"Raise"},{"location":"astspec/#syntax_33","text":"(Raise Expression)","title":"Syntax"},{"location":"astspec/#javascript-example_2","text":"throw 'abc'; (Raise (MuString abc ))","title":"JavaScript Example"},{"location":"astspec/#print","text":"Generic print expression","title":"Print"},{"location":"astspec/#syntax_34","text":"(Print Expression)","title":"Syntax"},{"location":"astspec/#ruby-example_5","text":"puts Hello World (Print (MuString Hello World ))","title":"Ruby Example"},{"location":"astspec/#for","text":"For s generalices the concept of comprehensions an indexed repetition. With a For you can build: ForComprehension , when the for expression is a yield. Scala's for comprehensions, Erlang's and Haskell's list comprehensions, and Haskell's do-syntaxt map to it. ForEach , when the for expression is not a yield. Java's for: , or some scenarios of scala's for map to it.","title":"For"},{"location":"astspec/#syntax_35","text":"(For [Statment] Expression)","title":"Syntax"},{"location":"astspec/#haskell-example","text":"m = [ f x | x - [1, 2, 3, 4] ] (Variable m (For [(Generator (VariablePattern x ) (MuList [(MuNumber 1), (MuNumber 2), (MuNumber 3), (MuNumber 4)]))] (Yield (Application (Reference f ) [(Reference x )]))))","title":"Haskell Example"},{"location":"astspec/#java-example_5","text":"for (Integer i : ints) { System.out.println(i); } (For [(Generator (VariablePattern i ) (Reference ints ))] (Print (Reference i )))","title":"Java Example"},{"location":"astspec/#forloop","text":"ForLoop represents the imperative programming c-style for loop:","title":"ForLoop"},{"location":"astspec/#syntax_36","text":"(ForLoop Expression Expression Expression Expression)","title":"Syntax"},{"location":"astspec/#c-example_5","text":"for (int i = 0; i 10; i++) { foo(i); } (ForLoop (Sequence [ TypeSignature i (SimpleType int []), Variable i (MuNumber 0.0)]) (Application (Primitive LessThan) [Reference i ,MuNumber 10.0]) (Assignment i (Application (Primitive Plus) [Reference i ,MuNumber 1.0])) (Application (Reference foo ) [Reference i ])))","title":"C Example"},{"location":"astspec/#javascript-example_3","text":"for (let i = 0; i 10; i++) { console.log(i); } (ForLoop (Variable i (MuNumber 0.0)) (Application (Reference ) [Reference i ,MuNumber 10.0]) (Assignment i (Application (Reference + ) [Reference i ,MuNumber 1.0])) (Send (Reference console ) (Reference log ) [Reference i ]))","title":"JavaScript Example"},{"location":"astspec/#sequence","text":"Generic sequence of statements","title":"Sequence"},{"location":"astspec/#syntax_37","text":"(Sequence [Expression])","title":"Syntax"},{"location":"astspec/#other","text":"Unrecognized expression, with optional description and body","title":"Other"},{"location":"astspec/#syntax_38","text":"(Other (Maybe Code) (Maybe Expression))","title":"Syntax"},{"location":"astspec/#arrow","text":"Generic arrow - AKA pair or entry - that is typically used to build dictionaries. It corresponds to ruby's, perl's and php's = operator, or ruby's and javascript's : operator","title":"Arrow"},{"location":"astspec/#syntax_39","text":"(Arrow Expression Expression) See MuDict for more details","title":"Syntax"},{"location":"astspec/#self","text":"Object oriented self-reference, like C-like this and Smalltalk-derived self","title":"Self"},{"location":"astspec/#syntax_40","text":"(Self)","title":"Syntax"},{"location":"astspec/#none","text":"Used as a placeholder for empty bodies.","title":"None"},{"location":"astspec/#syntax_41","text":"(None)","title":"Syntax"},{"location":"astspec/#break","text":"Used to break out of flow structure","title":"Break"},{"location":"astspec/#syntax_42","text":"(Break Expression)","title":"Syntax"},{"location":"astspec/#continue","text":"Used to jump over to next flow structure step","title":"Continue"},{"location":"astspec/#syntax_43","text":"(Continue Expression)","title":"Syntax"},{"location":"astspec/#munil","text":"Generic nothing value literal - nil , null , () or unit .","title":"MuNil"},{"location":"astspec/#syntax_44","text":"(MuNil)","title":"Syntax"},{"location":"astspec/#mudict","text":"Generic dictionary - AKA hash, table or map - value literal. Its expressions are normally a sequence of Arrow s","title":"MuDict"},{"location":"astspec/#syntax_45","text":"(MuDict Expression)","title":"Syntax"},{"location":"astspec/#python-example_1","text":"{'foo': 1} (MuDict (Arrow (MuString foo ) (MuNumber 1))) {'foo': 1, 'bar': 2} (MuDict (Sequence [ (Arrow (MuString foo ) (MuNumber 1)), (Arrow (MuString bar ) (MuNumber 2))])","title":"Python Example"},{"location":"astspec/#muobject","text":"Object oriented unnamed object literal","title":"MuObject"},{"location":"astspec/#syntax_46","text":"(MuObject Expression)","title":"Syntax"},{"location":"astspec/#javascript-example_4","text":"{} {foo: 1} {foo: 1, bar: 2} (MuObject MuNil) (MuObject (Attribute foo (MuNumber 1))) (MuObject (Sequence [ (Attribute foo (MuNumber 1)), (Attribute bar (MuNumber 2))]))","title":"JavaScript Example"},{"location":"astspec/#munumber-mubool-mustring-musymbol-and-muchar","text":"Generic number, boolean, string, symbol (atoms) and char literals","title":"MuNumber, MuBool, MuString, MuSymbol and MuChar"},{"location":"astspec/#syntax_47","text":"(MuNumber Double) (MuBool Bool) (MuString String) (MuSymbol String) (MuChar Char)","title":"Syntax"},{"location":"astspec/#ruby-example_6","text":"1 true hello :hello (Sequence [ (MuNumber 1), (MuBool True), (MuString hello ), (MuSymbol hello )])","title":"Ruby Example"},{"location":"astspec/#mutuple-and-mulist","text":"They represent tuples - generic non-uniform fixed-size collection of elements - and lists - generic uniform variable-size collection of elements. Lists typically map to arrays, lists or sequence-like structures.","title":"MuTuple and MuList"},{"location":"astspec/#syntax_48","text":"(MuTuple [Expression]) (MuList [Expression])","title":"Syntax"},{"location":"astspec/#testgroup-test-and-assert","text":"Generic test framework expressions used to represent unit tests. TestGroup represents a test grouping expression such as describe , context , etc Test represents a test expression such as it , etc Assert represents a test's assertion, such as assert.equals(...) , etc. It receives a boolean that represents whether the assertion is negated or not.","title":"TestGroup, Test and Assert"},{"location":"astspec/#syntax_49","text":"(TestGroup Expression Expression) (Test Expression Expression) (Assert Bool Assertion)","title":"Syntax"},{"location":"astspec/#javascript-example_5","text":"describe( succ , function() { it( succ of 3 is 4 , function() { assert.equals(succ(3), 4) }) }) TestGroup (MuString succ ) (Test (MuString succ of 3 is 4 ) (Assert False (Equality (Application (Reference succ ) [MuNumber 3.0]) (MuNumber 4.0))))","title":"Javascript Example"},{"location":"astspec/#python-example_2","text":"class TestGroup(unittest.TestCase): def test_succ_of_3_is_4(): self.assertEqual(succ(3), 4) TestGroup (MuString TestGroup ) (Test (MuString test_succ_of_3_is_4 ) (Assert False (Equality (Application (Reference succ ) [MuNumber 3.0]) (MuNumber 4.0))))","title":"Python Example"},{"location":"astspec/#assertion","text":"Assertions used within tests to dynamically ascertain the code's validity. An assertion can be one of: * Truth : Assert the truthfulness of a given expression. * Equality : Assert the equality of two given expressions. * Failure : Assert a given expression fails with a given error.","title":"Assertion"},{"location":"astspec/#syntax_50","text":"(Truth Expression) (Equality Expression Expression) (Failure Expression Expression)","title":"Syntax"},{"location":"astspec/#javascript-examples","text":"assert(true) Assert False (Truth (MuBool True)) assert.equals(3, 3) Assert False (Equality (MuNumber 3) (MuNumber 3)) assert.throws(function() { throw('error!') }, 'error!') Assert False (Failure (Lambda [] (Raise (MuString error! ))) (MuString error! ))","title":"Javascript Examples"},{"location":"astspec/#patterns","text":"Patterns are the second most important element of Mulang AST. They represent things that don't hold a value, but are instead used to match values, like patterns in imperative case or switch statements, functional pattern matching in match or case expressions, or exception matching in try-catch or begin-rescue -like statements in object oriented languages.","title":"Patterns"},{"location":"astspec/#variablepattern","text":"Variable pattern represent a variable match. It corresponds to normal formal parameters in precedural languages, and to simple pattern matching against a free identifier.","title":"VariablePattern"},{"location":"astspec/#syntax_51","text":"(VariablePattern String)","title":"Syntax"},{"location":"astspec/#javascript-example_6","text":"function foo(x, y) { } (Function foo [(Equation [(VariablePattern x ), (VariablePattern y )] (UnguardedBody MuNil))])","title":"JavaScript Example"},{"location":"astspec/#literalpattern","text":"Literal constant pattern","title":"LiteralPattern"},{"location":"astspec/#syntax_52","text":"(LiteralPattern String)","title":"Syntax"},{"location":"astspec/#example_5","text":"","title":"Example"},{"location":"astspec/#infixapplicationpattern","text":"Infix application pattern like 4:X","title":"InfixApplicationPattern"},{"location":"astspec/#syntax_53","text":"(InfixApplicationPattern Pattern String Pattern)","title":"Syntax"},{"location":"astspec/#caveats_1","text":"InfixApplicationPattern exposes the underying syntax and will be deprecated.","title":"Caveats"},{"location":"astspec/#applicationpattern","text":"prefix application pattern like f _","title":"ApplicationPattern"},{"location":"astspec/#syntax_54","text":"(ApplicationPattern String [Pattern])","title":"Syntax"},{"location":"astspec/#example_6","text":"","title":"Example"},{"location":"astspec/#tuplepattern","text":"tuple pattern like (3, _)","title":"TuplePattern"},{"location":"astspec/#syntax_55","text":"(TuplePattern [Pattern])","title":"Syntax"},{"location":"astspec/#example_7","text":"","title":"Example"},{"location":"astspec/#listpattern","text":"list pattern like [x, y, _]","title":"ListPattern"},{"location":"astspec/#syntax_56","text":"(ListPattern [Pattern])","title":"Syntax"},{"location":"astspec/#example_8","text":"","title":"Example"},{"location":"astspec/#functorpattern","text":"Prolog-like functor pattern, like f(X, 6) .","title":"FunctorPattern"},{"location":"astspec/#syntax_57","text":"(FunctorPattern Identifier [Pattern])","title":"Syntax"},{"location":"astspec/#example_9","text":"","title":"Example"},{"location":"astspec/#aspattern","text":"","title":"AsPattern"},{"location":"astspec/#syntax_58","text":"(AsPattern Identifier Pattern)","title":"Syntax"},{"location":"astspec/#example_10","text":"","title":"Example"},{"location":"astspec/#typepattern","text":"A type pattern, like in exception handling constructs in most object-oriented languages","title":"TypePattern"},{"location":"astspec/#syntax_59","text":"(TypePattern Identifier)","title":"Syntax"},{"location":"astspec/#example_11","text":"","title":"Example"},{"location":"astspec/#wildcardpattern","text":"Wildcard pattern, typically _ in functional an logic programming languages.","title":"WildcardPattern"},{"location":"astspec/#syntax_60","text":"(WildcardPattern)","title":"Syntax"},{"location":"astspec/#unionpattern","text":"","title":"UnionPattern"},{"location":"astspec/#syntax_61","text":"(UnionPattern [Pattern])","title":"Syntax"},{"location":"astspec/#otherpattern","text":"Other unrecognized pattern","title":"OtherPattern"},{"location":"astspec/#syntax_62","text":"(OtherPattern)","title":"Syntax"},{"location":"astspec/#primitive-operators","text":"Primitive operators represent low-level language operations that are well known and common to most languages, usually in the fashion of operators. They are natively supported by mulang. Absolute : numeric abs -like absolute operator AllSatisfy : collection all -like / every -like operator And : -like and operator AnySatisfy : collection any -like / some -like operator BackwardComposition : (g f)(x) = (g . f)(x) = g(f(x)) operator BitwiseAnd : bit-level -like and operator BitwiseLeftShift : bit-level left -like shift operator BitwiseOr : bit-level | -like or operator BitwiseRightShift : bit-level right -like shift operator BitwiseXor : bit-level ^ -like xor operator Ceil : numeric ceil -like ceiling operator Collect : collection map -like operator Count : collection count -like operator Detect : collection find -like search operator DetectMax : collection max -like maximum operator DetectMin : collection min -like minumum operator Divide : numeric / operator Equal : === -like equal operator Flatten : collection flatten -like operator Floor : numeric ceil -like floor operator ForwardComposition : (f g)(x) = (g . f)(x) = g(f(x)) operator Gather : collection flatmap -like operator GetAt : collection [] -like operator GreatherOrEqualThan : = operator GreatherThan : operator Hash : hashcode operator Inject : collection reduce -like / fold -like operator LessOrEqualThan : = operator LessThan : operator Max : max -like maximum value binary operator Min : min -like minimum value binary operator Minus : numeric - operator Modulo : numeric %-like modulo operator Multiply : numeric * operator Negation : ! -like not operator NotEqual : !== -like distinct operator NotSame : not reference-identical operator NotSimilar : not equal-ignoring-type operator Or : || -like or operator Otherwise : guard's otherwise operator Plus : numeric + operator Push : collection insertAtEnd -like operator Round : numeric round -like round operator Same : reference-identical operator Select : collection filter -like operator SetAt : collection []= -like operator Similar : equal-ignoring-type operator Size : collection length -like size operator","title":"Primitive Operators"},{"location":"astspec/#types","text":"When processing statically-typed languages, all type-information - regardless we are typing a function, a variable or a class - is represented with the Type ADT, can be one of: SimpleType : composed by a type identifier and zero or type more constraints ParameterizedType : composed by input type parmaters, an output type, and type constratins ConstrainedType : composed by just type constraints. OtherType : an unrecognized type Type s can be introduced in the Mulang AST using the following elements:","title":"Types"},{"location":"astspec/#typealias","text":"A TypeAlias represents a synonym for a type, like the type declaration in Haskell and Scala or C's typedef . It is a typical statically typed functional programming feature.","title":"TypeAlias"},{"location":"astspec/#syntax_63","text":"(TypeAlias Identifier Identifier)","title":"Syntax"},{"location":"astspec/#haskell-example_1","text":"type Point = (Int, Int) (TypeAlias Point (Int, Int) )","title":"Haskell Example"},{"location":"astspec/#typesignature","text":"A TypeSignature represents an explicit type annotation for a computation, variable or module, as you can find in Java or Haskell.","title":"TypeSignature"},{"location":"astspec/#syntax_64","text":"(TypeSignature Identifier Type)","title":"Syntax"},{"location":"astspec/#haskell-examples","text":"Simple types: name :: String (TypeSignature name (SimpleType String [])) Simple types and constraints: f :: Num a = a ```` ```haskell (TypeSignature f (SimpleType a [ Num a ])) Parameterized types: elem :: (Eq a, Foldable t) = a - t a - Bool ```` ```haskell (TypeSignature elem (ParameterizedType [ a , t a ] Bool [ Eq a , Foldable t ]))","title":"Haskell Examples"},{"location":"astspec/#java-examples_1","text":"In Java, as in most typed C-like languages, type signature and variable declarations are bound. This means that, for example, a local variable declaration will produce both a TypeSignature and a Variable expression. Variable and attribute types: String name; (TypeSignature name (SimpleType String [])) Method types: String f() { return null; } (TypeSignature f (ParameterizedType [] String [])) Method types with type parameters: A A f() { return null; } (TypeSignature f (ParameterizedType [] A [ A ])) Method types with type parameters and constraints: A super B void f(A a) {} (TypeSignature f (ParameterizedType [ A ] void [ A super B ])) Class or interfaces types: class A B extends C, D extends C { } (TypeSignature A (ConstrainedType [ B extends C , D extends C ]))","title":"Java Examples"},{"location":"astspec/#typecast","text":"A TypeCast represent explictly giving a type to an expression which may have static or dynamic impact on the program. It is aimed to represent type-casts in c-like languages and inline type signatures in functional languages.","title":"TypeCast"},{"location":"astspec/#syntax_65","text":"(TypeCast Expression Type)","title":"Syntax"},{"location":"astspec/#haskell-examples_1","text":"Simple types: ... = 4 :: Num a = a (TypeCast (MuNumber 4) (SimpleType a [ Num a ]))","title":"Haskell Examples"},{"location":"astspec/#java-examples_2","text":"Variable and attribute types: (Integer) 4; (TypeCast (MuNumber 4) (SimpleType Integer [])) (Option Integer ) something; (TypeCast (Reference something ) (SimpleType Option Integer []))","title":"Java Examples"},{"location":"astspec/#caveats_2","text":"The type constraints refer to type-constrained parametrizations that the cast introduces, and not any other kind of constraints the cast uses. That is whay the following Java code: (Num A ) something; produces: (TypeCast (Reference something ) (SimpleType Num A [])) instead of: (TypeCast (Reference something ) (SimpleType Num [ A ]))","title":"Caveats"},{"location":"build/","text":"Building mulang from source Setup To generate mulang executable, you have to build the project using stack : Install stack: wget -qO- https://get.haskellstack.org/ | sh Go to the mulang project directory and setup it: stack setup Build the project: If you need a production ready build, run ./build.sh If you just need a quick-to-compile development version, run ./build.sh --fast Installing and creating an executable # This will generate a `mulang` executable in the folder `~/.local/bin`. $ stack install # Run mulang $ mulang Running tests # This will build the project and run rspec and hspec tests $ ./test.sh Watching changes # This will build the project and run rspec and hspec tests, and wait for changes in hspec tests $ ./test.sh --file-watch Ruby wrapper See gem/README for more details. Building :warning: You will need Ruby 2.3+. cd gem # install ruby bundle install # wrap gem and run rspec tests rake Loading Run bin/console in the gem directory. JavaScript library See ghcjslib/README and https://www.npmjs.com/package/mulang for more details. mulang can also be compiled to JavaScript library using ghcjs and ghcjslib , which allows you to use it from node or the browser. Building :warning: you will need node = 7 installed on your system. If you have nvm , before starting run the following: sh $ nvm use $(cat ghcjslib/.nvmrc) # 1. Swap to GHCJS compiler ghcjslib/swap.sh # 2. Build ghcjslib release. It will be placed on ghcjslib/build/mulang.js ghcjslib/build.sh # 3. Run both mocha and hspec tests. ghcjslib/test.sh # 4. Run again for swapping back to ghc ghcjslib/swap.sh Loading in the browser: google-chrome ghcjslib/index.html in node : run node , and then, within the interpreter, run: let mulang = require('./ghcjslib/build/mulang.js'); Updating docs These site is build using mkdocs = 0.17 . You can install it using pip : $ pip install mkdocs From the project root folder, running ./docs/devinit will setup the docs, ./docs/devstart start the site locally, and mkdocs gh-deploy will deploy the documentation.","title":"Build"},{"location":"build/#building-mulang-from-source","text":"","title":"Building mulang from source"},{"location":"build/#setup","text":"To generate mulang executable, you have to build the project using stack : Install stack: wget -qO- https://get.haskellstack.org/ | sh Go to the mulang project directory and setup it: stack setup Build the project: If you need a production ready build, run ./build.sh If you just need a quick-to-compile development version, run ./build.sh --fast","title":"Setup"},{"location":"build/#installing-and-creating-an-executable","text":"# This will generate a `mulang` executable in the folder `~/.local/bin`. $ stack install # Run mulang $ mulang","title":"Installing and creating an executable"},{"location":"build/#running-tests","text":"# This will build the project and run rspec and hspec tests $ ./test.sh","title":"Running tests"},{"location":"build/#watching-changes","text":"# This will build the project and run rspec and hspec tests, and wait for changes in hspec tests $ ./test.sh --file-watch","title":"Watching changes"},{"location":"build/#ruby-wrapper","text":"See gem/README for more details.","title":"Ruby wrapper"},{"location":"build/#building","text":":warning: You will need Ruby 2.3+. cd gem # install ruby bundle install # wrap gem and run rspec tests rake","title":"Building"},{"location":"build/#loading","text":"Run bin/console in the gem directory.","title":"Loading"},{"location":"build/#javascript-library","text":"See ghcjslib/README and https://www.npmjs.com/package/mulang for more details. mulang can also be compiled to JavaScript library using ghcjs and ghcjslib , which allows you to use it from node or the browser.","title":"JavaScript library"},{"location":"build/#building_1","text":":warning: you will need node = 7 installed on your system. If you have nvm , before starting run the following: sh $ nvm use $(cat ghcjslib/.nvmrc) # 1. Swap to GHCJS compiler ghcjslib/swap.sh # 2. Build ghcjslib release. It will be placed on ghcjslib/build/mulang.js ghcjslib/build.sh # 3. Run both mocha and hspec tests. ghcjslib/test.sh # 4. Run again for swapping back to ghc ghcjslib/swap.sh","title":"Building"},{"location":"build/#loading_1","text":"in the browser: google-chrome ghcjslib/index.html in node : run node , and then, within the interpreter, run: let mulang = require('./ghcjslib/build/mulang.js');","title":"Loading"},{"location":"build/#updating-docs","text":"These site is build using mkdocs = 0.17 . You can install it using pip : $ pip install mkdocs From the project root folder, running ./docs/devinit will setup the docs, ./docs/devstart start the site locally, and mkdocs gh-deploy will deploy the documentation.","title":"Updating docs"},{"location":"clispec/","text":"Command Line Tool You can also use Mulang from the Command Line, without having to interact with Haskell code. This tool allows to perform most common analysis out of the box by using a JSON spec. It supports five different kinds of analysis: Expectation analysis : you can pass inspections that will be tested against the provied program. Expectations answer questions like: does the function X call the function Y? or does the program use if's? . Smell analysis : instead of asking explcit questions to the program, the smells analysis implicitly runs specific inspections - that denote bad code - in orden to know if any of them is matched. Intermediate Language analysis : you can ask the tool to generate the Mulang AST for a given source code. Signature analysis : report the signatures of the computations present in source code. Test analysis : run basic unit-like tests over the code. Examples Let's see some usage samples: With intransitive expectations $ mulang ' { sample : { tag : CodeSample , language : Haskell , content : x = z + 1 }, spec : { expectations : [ { binding : Intransitive:x , inspection : Uses:z } ] } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [ { expectation : { binding : Intransitive:x , inspection : Uses:z }, result : true } ] } With unscoped expectations $ mulang ' { sample : { tag : CodeSample , language : Haskell , content : x = 1 }, spec : { expectations : [ { binding : * , inspection : Declares:x } ] } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [ { result : true, expectation : { binding : * , inspection : Declares:x } } ] } With expectations with matchers $ mulang ' { sample : { tag : CodeSample , language : Python3 , content : print(\\ bye\\ )\\nexit(1) }, spec : { expectations : [ { binding : * , inspection : Calls:exit:WithNumber:0 }, { binding : * , inspection : Prints:WithString:\\ bye\\ } ] } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [ { expectation : { inspection : Calls:exit:WithNumber:0 , binding : * }, result : false }, { expectation : { inspection : Prints:WithString:\\ bye\\ , binding : * }, result : true } ] } With custom expectations For more information about EDL syntax see EDL Spec $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function plusOne(x) { return x + 1 } }, spec : { customExpectations : expectation: declares function `plusOne` that (returns with math);\\nexpectation: !declares variable with literal } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [ { result : true, expectation : { binding : * , inspection : Declares:x } } ] } With signature analysis $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return x + y; } }, spec : { signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [ { expectation : { binding : custom , inspection : E0 }, result : true }, { expectation : { inspection : E1 , binding : custom }, result : true } ] } With broken input $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y { return x + y; } }, spec : { signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } }' | json_pp { tag : AnalysisFailed , reason : Sample code parsing error } With AST as input $ mulang ' { sample : { tag : MulangSample , ast : { tag : Sequence , contents : [ { tag : Variable , contents : [ x , { tag : MuNumber , contents : 1 } ] }, { tag : Variable , contents : [ y , { tag : MuNumber , contents : 2 } ] } ] } }, spec : { signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } } ' | json_pp { tag : AnalysisCompleted , signatures : [ -- x , -- y ] } With smell analysis, by inclusion $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { smellsSet : { tag : NoSmells , include : [ ReturnsNil , DoesNullTest ] } } } ' | json_pp { tag : AnalysisCompleted , smells : [ { binding : foo , inspection : ReturnsNil } ] } With smell analysis, by exclusion $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { smellsSet : { tag : AllSmells , exclude : [ ReturnsNil ] } } } ' | json_pp { tag : AnalysisCompleted , smells : [], } With expressiveness smells Expressivnes smells are like other smells - they can be included or excluded using the smellsSet settings. However, their behaviour is also controlled by the domainLanguage setting, which you can configure: $ mulang ' { sample : { tag : CodeSample , language : Prolog , content : son(Parent, Son):-parentOf(Son, Parent).parentOf(bart, homer). }, spec : { smellsSet : { tag : AllSmells }, domainLanguage : { caseStyle : SnakeCase , minimumIdentifierSize : 4, jargon : [ id ] } } }' | json_pp { tag : AnalysisCompleted , smells : [ { inspection : HasTooShortIdentifiers , binding : son }, { binding : parentOf , inspection : HasWrongCaseIdentifiers } ] } Also, if you want to use HasMisspelledIdentifiers smell, you need to specify a dictionary - with must be ordered, downcased and with unique words only: $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { smellsSet : { tag : AllSmells }, domainLanguage : { dictionaryFilePath : /usr/share/dict/words } } }' | json_pp { tag : AnalysisCompleted , smells : [ { inspection : ReturnsNil , binding : foo }, { inspection : HasMisspelledIdentifiers , binding : foo } ] } With typos smells Smell typos are special since they interact with some expectations: HasDeclarationTypos is a smell that will be activated after a Declares - or any similar expectation like DeclaresProcedure or Delegates - expectation is set. HasUsageTypos will be activated after a Uses expectation is set. mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function pls(x, y) { return x + y; } }, spec : { expectations : [ { binding : * , inspection : Declares:plus } ], smellsSet : { tag : NoSmells , include : [ HasDeclarationTypos ] } } } ' | json_pp { outputAst : null, tag : AnalysisCompleted , expectationResults : [ { expectation : { inspection : Declares:plus , binding : * }, result : false } ], smells : [ { inspection : HasDeclarationTypos:plus , binding : pls } ], testResults : [], signatures : [] } With intermediate language generation $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { includeOutputAst : true } } ' | json_pp { tag : AnalysisCompleted , outputAst : { tag : Function , contents : [ foo , [ [ [ { tag : VariablePattern , contents : x }, { tag : VariablePattern , contents : y } ], { tag : UnguardedBody , contents : { contents : { tag : MuNil }, tag : Return } } ] ] ] } } With normalization options $ mulang ' { sample : { tag : MulangSample , normalizationOptions : { insertImplicitReturn : true }, ast : { tag : Procedure , contents : [ foo , [ [ [ { tag : VariablePattern , contents : x } ], { tag : UnguardedBody , contents : { tag : Application , contents : [ { tag : Primitive , contents : Multiply }, [ { tag : MuNumber , contents : 2 }, { tag : Reference , contents : x } ] ] } } ] ] ] } }, spec : { includeOutputAst : true } } ' | json_pp { tag : AnalysisCompleted , signatures : [], smells : [], expectationResults : [], testResults : [], outputAst : { tag : Procedure , contents : [ foo , [ [ [ { contents : x , tag : VariablePattern } ], { contents : { tag : Return , contents : { contents : [ { tag : Primitive , contents : Multiply }, [ { tag : MuNumber , contents : 2 }, { contents : x , tag : Reference } ] ], tag : Application } }, tag : UnguardedBody } ] ] ] } } With test running mulang '{ sample : { tag : CodeSample , language : JavaScript , content : function f(x) { return x + 1 } }, spec : { testAnalysisType : { tag : ExternalTests , test : { tag : CodeSample , language : JavaScript , content : it(\\ f increments by one\\ , function() { assert.equals(f(1), 2) }) } } } }' | json_pp { tag : AnalysisCompleted , testResults : [ { description : [ f increments by one ], status : { tag : Success } } ] } For further detail on this spec, see Code Execution Code Execution As of v4.4.0, mulang provides basic support for executing its AST. This feature can accessed through a testAnalysisType spec, such as the one shown in this section . Currently, support is given for executing the following AST elements: Application Assert Assignment ForLoop If Lambda MuBool MuList MuNil MuNumber MuString Print Raise Reference Return Sequence Function Procedure Method Variable While Examples mulang '{ sample : { tag : CodeSample , language : JavaScript , content : function f(x) { return x + 1 } }, spec : { testAnalysisType : { tag : ExternalTests , test : { tag : CodeSample , language : JavaScript , content : it(\\ f increments by one\\ , function() { assert.equals(f(1), 2) }) } } } }' | json_pp { tag : AnalysisCompleted , testResults : [ { status : { tag : Success }, description : [ f increments by one ] } ] } Since both the code and tests are parsed to and run as an AST, the two of them needn't be in the same language: mulang '{ sample : { tag : CodeSample , language : Python , content : def f(): x = 0 while x 10: x += 1 return x }, spec : { testAnalysisType : { tag : ExternalTests , test : { tag : CodeSample , language : JavaScript , content : it(\\ f returns 10\\ , function() { assert.equals(f(), 10) }) } } } }' | json_pp { tag : AnalysisCompleted , testResults : [ { status : { tag : Success }, description : [ f returns 10 ] } ] }","title":"Comand Line"},{"location":"clispec/#command-line-tool","text":"You can also use Mulang from the Command Line, without having to interact with Haskell code. This tool allows to perform most common analysis out of the box by using a JSON spec. It supports five different kinds of analysis: Expectation analysis : you can pass inspections that will be tested against the provied program. Expectations answer questions like: does the function X call the function Y? or does the program use if's? . Smell analysis : instead of asking explcit questions to the program, the smells analysis implicitly runs specific inspections - that denote bad code - in orden to know if any of them is matched. Intermediate Language analysis : you can ask the tool to generate the Mulang AST for a given source code. Signature analysis : report the signatures of the computations present in source code. Test analysis : run basic unit-like tests over the code.","title":"Command Line Tool"},{"location":"clispec/#examples","text":"Let's see some usage samples:","title":"Examples"},{"location":"clispec/#with-intransitive-expectations","text":"$ mulang ' { sample : { tag : CodeSample , language : Haskell , content : x = z + 1 }, spec : { expectations : [ { binding : Intransitive:x , inspection : Uses:z } ] } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [ { expectation : { binding : Intransitive:x , inspection : Uses:z }, result : true } ] }","title":"With intransitive expectations"},{"location":"clispec/#with-unscoped-expectations","text":"$ mulang ' { sample : { tag : CodeSample , language : Haskell , content : x = 1 }, spec : { expectations : [ { binding : * , inspection : Declares:x } ] } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [ { result : true, expectation : { binding : * , inspection : Declares:x } } ] }","title":"With unscoped expectations"},{"location":"clispec/#with-expectations-with-matchers","text":"$ mulang ' { sample : { tag : CodeSample , language : Python3 , content : print(\\ bye\\ )\\nexit(1) }, spec : { expectations : [ { binding : * , inspection : Calls:exit:WithNumber:0 }, { binding : * , inspection : Prints:WithString:\\ bye\\ } ] } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [ { expectation : { inspection : Calls:exit:WithNumber:0 , binding : * }, result : false }, { expectation : { inspection : Prints:WithString:\\ bye\\ , binding : * }, result : true } ] }","title":"With expectations with matchers"},{"location":"clispec/#with-custom-expectations","text":"For more information about EDL syntax see EDL Spec $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function plusOne(x) { return x + 1 } }, spec : { customExpectations : expectation: declares function `plusOne` that (returns with math);\\nexpectation: !declares variable with literal } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [ { result : true, expectation : { binding : * , inspection : Declares:x } } ] }","title":"With custom expectations"},{"location":"clispec/#with-signature-analysis","text":"$ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return x + y; } }, spec : { signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [ { expectation : { binding : custom , inspection : E0 }, result : true }, { expectation : { inspection : E1 , binding : custom }, result : true } ] }","title":"With signature analysis"},{"location":"clispec/#with-broken-input","text":"$ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y { return x + y; } }, spec : { signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } }' | json_pp { tag : AnalysisFailed , reason : Sample code parsing error }","title":"With broken input"},{"location":"clispec/#with-ast-as-input","text":"$ mulang ' { sample : { tag : MulangSample , ast : { tag : Sequence , contents : [ { tag : Variable , contents : [ x , { tag : MuNumber , contents : 1 } ] }, { tag : Variable , contents : [ y , { tag : MuNumber , contents : 2 } ] } ] } }, spec : { signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } } ' | json_pp { tag : AnalysisCompleted , signatures : [ -- x , -- y ] }","title":"With AST as input"},{"location":"clispec/#with-smell-analysis-by-inclusion","text":"$ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { smellsSet : { tag : NoSmells , include : [ ReturnsNil , DoesNullTest ] } } } ' | json_pp { tag : AnalysisCompleted , smells : [ { binding : foo , inspection : ReturnsNil } ] }","title":"With smell analysis, by inclusion"},{"location":"clispec/#with-smell-analysis-by-exclusion","text":"$ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { smellsSet : { tag : AllSmells , exclude : [ ReturnsNil ] } } } ' | json_pp { tag : AnalysisCompleted , smells : [], }","title":"With smell analysis, by exclusion"},{"location":"clispec/#with-expressiveness-smells","text":"Expressivnes smells are like other smells - they can be included or excluded using the smellsSet settings. However, their behaviour is also controlled by the domainLanguage setting, which you can configure: $ mulang ' { sample : { tag : CodeSample , language : Prolog , content : son(Parent, Son):-parentOf(Son, Parent).parentOf(bart, homer). }, spec : { smellsSet : { tag : AllSmells }, domainLanguage : { caseStyle : SnakeCase , minimumIdentifierSize : 4, jargon : [ id ] } } }' | json_pp { tag : AnalysisCompleted , smells : [ { inspection : HasTooShortIdentifiers , binding : son }, { binding : parentOf , inspection : HasWrongCaseIdentifiers } ] } Also, if you want to use HasMisspelledIdentifiers smell, you need to specify a dictionary - with must be ordered, downcased and with unique words only: $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { smellsSet : { tag : AllSmells }, domainLanguage : { dictionaryFilePath : /usr/share/dict/words } } }' | json_pp { tag : AnalysisCompleted , smells : [ { inspection : ReturnsNil , binding : foo }, { inspection : HasMisspelledIdentifiers , binding : foo } ] }","title":"With expressiveness smells"},{"location":"clispec/#with-typos-smells","text":"Smell typos are special since they interact with some expectations: HasDeclarationTypos is a smell that will be activated after a Declares - or any similar expectation like DeclaresProcedure or Delegates - expectation is set. HasUsageTypos will be activated after a Uses expectation is set. mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function pls(x, y) { return x + y; } }, spec : { expectations : [ { binding : * , inspection : Declares:plus } ], smellsSet : { tag : NoSmells , include : [ HasDeclarationTypos ] } } } ' | json_pp { outputAst : null, tag : AnalysisCompleted , expectationResults : [ { expectation : { inspection : Declares:plus , binding : * }, result : false } ], smells : [ { inspection : HasDeclarationTypos:plus , binding : pls } ], testResults : [], signatures : [] }","title":"With typos smells"},{"location":"clispec/#with-intermediate-language-generation","text":"$ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { includeOutputAst : true } } ' | json_pp { tag : AnalysisCompleted , outputAst : { tag : Function , contents : [ foo , [ [ [ { tag : VariablePattern , contents : x }, { tag : VariablePattern , contents : y } ], { tag : UnguardedBody , contents : { contents : { tag : MuNil }, tag : Return } } ] ] ] } }","title":"With intermediate language generation"},{"location":"clispec/#with-normalization-options","text":"$ mulang ' { sample : { tag : MulangSample , normalizationOptions : { insertImplicitReturn : true }, ast : { tag : Procedure , contents : [ foo , [ [ [ { tag : VariablePattern , contents : x } ], { tag : UnguardedBody , contents : { tag : Application , contents : [ { tag : Primitive , contents : Multiply }, [ { tag : MuNumber , contents : 2 }, { tag : Reference , contents : x } ] ] } } ] ] ] } }, spec : { includeOutputAst : true } } ' | json_pp { tag : AnalysisCompleted , signatures : [], smells : [], expectationResults : [], testResults : [], outputAst : { tag : Procedure , contents : [ foo , [ [ [ { contents : x , tag : VariablePattern } ], { contents : { tag : Return , contents : { contents : [ { tag : Primitive , contents : Multiply }, [ { tag : MuNumber , contents : 2 }, { contents : x , tag : Reference } ] ], tag : Application } }, tag : UnguardedBody } ] ] ] } }","title":"With normalization options"},{"location":"clispec/#with-test-running","text":"mulang '{ sample : { tag : CodeSample , language : JavaScript , content : function f(x) { return x + 1 } }, spec : { testAnalysisType : { tag : ExternalTests , test : { tag : CodeSample , language : JavaScript , content : it(\\ f increments by one\\ , function() { assert.equals(f(1), 2) }) } } } }' | json_pp { tag : AnalysisCompleted , testResults : [ { description : [ f increments by one ], status : { tag : Success } } ] } For further detail on this spec, see Code Execution","title":"With test running"},{"location":"clispec/#code-execution","text":"As of v4.4.0, mulang provides basic support for executing its AST. This feature can accessed through a testAnalysisType spec, such as the one shown in this section . Currently, support is given for executing the following AST elements: Application Assert Assignment ForLoop If Lambda MuBool MuList MuNil MuNumber MuString Print Raise Reference Return Sequence Function Procedure Method Variable While","title":"Code Execution"},{"location":"clispec/#examples_1","text":"mulang '{ sample : { tag : CodeSample , language : JavaScript , content : function f(x) { return x + 1 } }, spec : { testAnalysisType : { tag : ExternalTests , test : { tag : CodeSample , language : JavaScript , content : it(\\ f increments by one\\ , function() { assert.equals(f(1), 2) }) } } } }' | json_pp { tag : AnalysisCompleted , testResults : [ { status : { tag : Success }, description : [ f increments by one ] } ] } Since both the code and tests are parsed to and run as an AST, the two of them needn't be in the same language: mulang '{ sample : { tag : CodeSample , language : Python , content : def f(): x = 0 while x 10: x += 1 return x }, spec : { testAnalysisType : { tag : ExternalTests , test : { tag : CodeSample , language : JavaScript , content : it(\\ f returns 10\\ , function() { assert.equals(f(), 10) }) } } } }' | json_pp { tag : AnalysisCompleted , testResults : [ { status : { tag : Success }, description : [ f returns 10 ] } ] }","title":"Examples"},{"location":"edlspec/","text":"Expectations Definition Language Reference EDL allows to express more complex expectations by combining existing inspection. Basic syntax expectation [ name ]: expectation body ; For example, this is the simplest expectation you can declare: expectation: calls; This expectation performs a simple query that checks that something is called - like a function, a procedure - and it behaves exactly as the * Calls:* expectation. If you want to make it more explicit that you are expecting to call something , you can also write it this way... expectation: calls something; ...which is just syntactic sugar - the something keyword is just a dummy token you can add to make the expectation syntax more human-readable. Likewise, you can use somewhere keyword in order to be more explicit about using an unscoped query - more on this later: expectation: %% equivalent to previous example, `somewhere` is just a dummy token somewhere calls something; Although you can declare unnamed expectations, it is usually more convenient to add an intention-revealing name: expectation you should call something : calls something; The inspection names match exactly with the standard expectation format, but it is more relaxed, you can it write it in three diferent formats: UpperCamelCase , which is the standard syntax, e.g. UsesIf lowerCamelCase , e.g. usesIf case insensitive words , e.g. uses if , Uses If and uses IF However, using lower case words - uses if - is the preferred case. This means that all the following declarations are equivalent: % ok expectation: UsesIf; % ok expectation: usesIf; % better expectation: uses if; More examples: expectation must declare something : declares; expectation must declare something : %% exactly the same as previous example declares something; expectation assignment operator must be used : assigns; expectation a class must be declared : declares class; expectation a function must be declared : declares function; Predicates Like with standard expectations, you can use predicates with the inspections. The simplest of them is the named predicate, that matches a name exactly against the given identifier: expectation `System` must be used : %% equivalent to the standard expectation * Uses:=System uses `System`; expectation `exit` must be called : %% equivalent to the standard expectation * Calls:=exit calls `exit`; However, all the predicates are available to EDL: %% matches things like `amount`, `totalAmount` or `amountOfHouses` expectation assignment a variable similar to `amount` : %% equivalent to * Assigns:~amount assigns something like `amount`; expectation must declare a class aside of `Dog` : %% equivalent to * DeclaresClass:^Dog declares class except `Dog`; Also, there EDL exposes more predicates: expectation declares methods apart from getters : declares method unlike `get`; expectation must declare `feed` or `bark` : declares method in (`feed`, `bark`); expectation must call `feed` or `bark` : calls something in (`feed`, `bark`); expectation must call something similar to `feed` or `bark` : calls something like in (`feed`, `bark`); expectation must call something apart from `feed` or `bark` : calls something except in (`feed`, `bark`); expectation must declare something apart from classes like `Base` or `Abstract` : declares class unlike in (`Base`, `Abstract`); Boolean operators on unscoped queries EDL allows to use logical operations with - unscoped , more on that later - queries: %% negation expectation must not call anything : ! calls something; %% logical-or expectation must declare a class, enum or interface named `Pet` : declares enumeration `Pet` || declares class `Pet` || declares interface `Pet`; %% logical-and expectation must declare `Owner` and `Pet` : %% however in most cases, it is better to declare two different, separate %% expectations declares `Owner` declares `Pet`; Such operations don't have an equivalence on the standard expectations, and are unique to EDL. Scopes Also, custom expectations mmy be scoped using within and through , which allow inspecting only a given portion of the code: within performs intransitive cuts while through performs transitive cuts. expectation `HouseBuilder` must raise something : %% this will work if within the lexical scope of %% HouseBuilder a raise statement is used %% equivalent to Intransitive:HouseBuilder Raises within `HouseBuilder` raises something; expectation `HouseBuilder` must raise something : %% this will work if within the lexical scope of %% HouseBuilder a raise statement is used, or if any code outside %% the lexical scope of HouseBuilder raises an exception %% equivalent to HouseBuilder Raises through `HouseBuilder` raises something; expectation `HouseBuilder.builder` must create a new `House` : %% equivalent to Instransitive:HouseBuilder.builder Instantiates:House within `HouseBuilder.builder` instantiates `House`; expectation In the context of `Tree`, something other than `foo` is called : %% equivalent to Tree Calls:^foo through `Tree` calls something except `foo`; Queries that use a scope operator are called scoped queries . Conversely unscoped queries are those that don't use one. Matchers Some inspections support an optional matcher argument, that allow you to provide additional conditions using the with keyword: expectation `exit` must be called with value 0 : %% equivalent to * Calls:exit:WithNumber:0 calls `exit` with 0; expectation `tell` must be called with value 10 and true : %% equivalent to * Calls:tell:WithNumber:10:WithTrue calls `tell` with (10, true); expectation `play` must be called with this : %% equivalent to * Calls:play:WithSelf calls `play` with self; expectation uses a repeat with a non-literal amount of iterations : %% matches repeat blocks where the repeat count expression is a non-literal %% and the loop body is anything uses repeat with (nonliteral, anything); expectation uses a repeat with a non-literal amount of iterations : %% shorter version of previous example uses repeat with nonliteral; Most of the matchers are designed to perform literal queries, but some of them allow more complex matching: expectation the method `getTotalAmount` must return an arithmetic expresion : %% equivalent to Intransitive:getTotalAmmount Returns:WithMath within `getTotalAmmount` returns with math; expectation a method that performs boolean operations must be declared : %% equivalent to * DeclaresMethod:WithLogic declares method with logic; expectation `getAge` must not return a hardcoded value: %% equivalent to Intransitive:getAge Returns:WithNonliteral within `getAge` returns with nonliteral; As you can see in previous examples, many of the simplest matchers can also be used in the standard expectation syntax. However, EDL also supports the that matcher, that allows you to build complex, nested queries: expectation must declare a class that uses an if : declares class with something that (uses if); expectation must declare a class that uses an if : %% shorter, equivalent version of previous example declares class that (uses if); expectation `VirtualPet.HappyState` must declare a getter that returns a literal value : within `VirtualPet.HappyState` declares method like `get` that (returns with literal); expectation uses a c-style for-loop that declares variable `x` : uses for loop with ( something that (declares variable `x`), anything, anything, anything); expectation uses a c-style for-loop that declares variable `x` : %% even shorter version of previous example uses for loop that (declares variable `x`); that -queries can be nested, thus allowing you to write quite abstract expectations: expectation package `tamagochi` must declare a class with a method that returns an arithmethic expression : within `tamagochi` declares class that ( declares method that ( returns with math)); expectation repeats `next()` 3 times : uses repeat with (3, something that (calls `next`)); Previous logical operators may also be used with that -queries: expectation must declare a procedure that uses ifs : declares procedure that (uses if); expectation must declare a procedure that uses ifs but not while : declares procedure that (uses if ! uses while); expectation does not nest a while within an if : ! uses if with ( anything, something that uses while, anything) ! uses if with ( anything, anything, something that (uses while)); expectation uses an if that does not nest a while inside it : uses if with ( anything, something that (!uses while), something that (!uses while)); Supported inspections This is the complete list of inspections that support matchers: assigns : accepts a matcher that matches the assigned value calls : accepts a matcher that matches the passed arguments declares attribute : accepts a matcher that matches the initial value declares class : accepts a matcher that matches any of the body expressions declares entry point : accepts a matchers that matches the entry point body declares function : accepts a matcher that matches any of the body expressions declares interface : accepts a matcher that matches any of the body expressions declares method : accepts a matcher that matches any of the body expressions declares object : accepts a matcher that matches any of the body expressions declares procedure : accepts a matcher that matches any of the body expressions declares variable : accepts a matcher that matches the initial value returns : accepts a matcher that matches the returned value uses for each : accepts a matcher that matches the generator, and the loop body uses for loop : accepts a matcher that matches the initializer expression, the condition expression, the increment expression and the loop body uses if : accepts a matcher that matches the condition, the then expression and the else expression uses lambda : accepts a matcher that matches the lambda body uses print : accepts a matcher that matchers the printed value uses repeat : accepts a matcher that matches the repeat expression and the loop body uses while : accepts a matcher that matches the condition expression and the loop body uses yield : accepts a matcher that matches the yielded value Supported matchers ( matcher1 , matcher2 .., matcherN ) : matches a tuple of expressions, like a callable's arguments or a control structure parts. If less elements than required are passed, the list is padded with anything matchers. character : matches a single character number : matches a number literal string : matches a single string symbol : matches a symbol literal anything : matches anything false and true : matches the true and false literals literal : matches any literal logic : matches a boolean expression math : matches an arithmetic expresion nil : matches the nil/null literal nonliteral : matches a non-literal expression self : matches the self/this literal that ( other query ) : matches an expression that makes the given query true Counters EDL allows you to define expectations by counting and comparing matches of another query, by using the count , = , = and = operators: expectation must perform at least three calls : count(calls) = 3; expectation must declare three instances of `Tax` : count(inherits `Tax`) = 3; expectation must declare three subclasses of `Tax` and two subclasses of `Product` : count(inherits `Tax`) = 3 count(inherits `Product`) = 2; expectation must declare no more than 4 methods in class `Queue` : within `Queue` count(declares method) = 4; expectation `max` must have 2 returns : within `max` count(returns) = 2; Finally, counters may be added, using the + opertor: expectation The `Bar` must declare 4 or more methods related to beer or whisky : within `Bar` count (declares method like `whisky`) + count (declares method like `beer`) = 4; Supported counters Not all inspections can be counted. Currently, only the following are supported: calls declares attribute declares class declares function declares interface declares method declares object declares procedure declares variable returns uses uses for each uses for loop uses for uses if uses lambda uses print uses repeat uses switch uses try uses while uses yield All the primitive operator inspections , e.g. uses plus or uses size Boolean operators on scoped queries Finally, EDL allows to use logical operations with scoped queries: %% negation expectation must not assign anything in `main` : not (within 'main' assigns); %% logical-or expectation pacakge `vet` must declare a class, enum or interface named `Pet` : (within `vet` declares enumeration `Pet`) or (within `vet` declares class `Pet`) or (within `vet` declares interface `Pet`); %% alternate definition, which is equivalent provided package `vet` exists expectation pacakge `vet` must declare a class, enum or interface named `Pet` : within `vet` declares enumeration `Pet` || declares class `Pet` || declares interface `Pet`; %% logical-and expectation `Pet` must declare `eat` and `Owner` must send it : %% however in most cases, it is better to declare two different, separate %% expectations (within `Pet` declares `eat`) and (within `Owner` sends `eat`); \u26a0\ufe0f Caveats Mulang by default will apply autocorrection rules that transform language-dependant inspections - like Uses:length in JavaScript - into proper operator inspections like UsesSize . Those transformation will not be applied when using EDL , so be careful when using languages primitives.","title":"EDL Spec"},{"location":"edlspec/#expectations-definition-language-reference","text":"EDL allows to express more complex expectations by combining existing inspection.","title":"Expectations Definition Language Reference"},{"location":"edlspec/#basic-syntax","text":"expectation [ name ]: expectation body ; For example, this is the simplest expectation you can declare: expectation: calls; This expectation performs a simple query that checks that something is called - like a function, a procedure - and it behaves exactly as the * Calls:* expectation. If you want to make it more explicit that you are expecting to call something , you can also write it this way... expectation: calls something; ...which is just syntactic sugar - the something keyword is just a dummy token you can add to make the expectation syntax more human-readable. Likewise, you can use somewhere keyword in order to be more explicit about using an unscoped query - more on this later: expectation: %% equivalent to previous example, `somewhere` is just a dummy token somewhere calls something; Although you can declare unnamed expectations, it is usually more convenient to add an intention-revealing name: expectation you should call something : calls something; The inspection names match exactly with the standard expectation format, but it is more relaxed, you can it write it in three diferent formats: UpperCamelCase , which is the standard syntax, e.g. UsesIf lowerCamelCase , e.g. usesIf case insensitive words , e.g. uses if , Uses If and uses IF However, using lower case words - uses if - is the preferred case. This means that all the following declarations are equivalent: % ok expectation: UsesIf; % ok expectation: usesIf; % better expectation: uses if; More examples: expectation must declare something : declares; expectation must declare something : %% exactly the same as previous example declares something; expectation assignment operator must be used : assigns; expectation a class must be declared : declares class; expectation a function must be declared : declares function;","title":"Basic syntax"},{"location":"edlspec/#predicates","text":"Like with standard expectations, you can use predicates with the inspections. The simplest of them is the named predicate, that matches a name exactly against the given identifier: expectation `System` must be used : %% equivalent to the standard expectation * Uses:=System uses `System`; expectation `exit` must be called : %% equivalent to the standard expectation * Calls:=exit calls `exit`; However, all the predicates are available to EDL: %% matches things like `amount`, `totalAmount` or `amountOfHouses` expectation assignment a variable similar to `amount` : %% equivalent to * Assigns:~amount assigns something like `amount`; expectation must declare a class aside of `Dog` : %% equivalent to * DeclaresClass:^Dog declares class except `Dog`; Also, there EDL exposes more predicates: expectation declares methods apart from getters : declares method unlike `get`; expectation must declare `feed` or `bark` : declares method in (`feed`, `bark`); expectation must call `feed` or `bark` : calls something in (`feed`, `bark`); expectation must call something similar to `feed` or `bark` : calls something like in (`feed`, `bark`); expectation must call something apart from `feed` or `bark` : calls something except in (`feed`, `bark`); expectation must declare something apart from classes like `Base` or `Abstract` : declares class unlike in (`Base`, `Abstract`);","title":"Predicates"},{"location":"edlspec/#boolean-operators-on-unscoped-queries","text":"EDL allows to use logical operations with - unscoped , more on that later - queries: %% negation expectation must not call anything : ! calls something; %% logical-or expectation must declare a class, enum or interface named `Pet` : declares enumeration `Pet` || declares class `Pet` || declares interface `Pet`; %% logical-and expectation must declare `Owner` and `Pet` : %% however in most cases, it is better to declare two different, separate %% expectations declares `Owner` declares `Pet`; Such operations don't have an equivalence on the standard expectations, and are unique to EDL.","title":"Boolean operators on unscoped queries"},{"location":"edlspec/#scopes","text":"Also, custom expectations mmy be scoped using within and through , which allow inspecting only a given portion of the code: within performs intransitive cuts while through performs transitive cuts. expectation `HouseBuilder` must raise something : %% this will work if within the lexical scope of %% HouseBuilder a raise statement is used %% equivalent to Intransitive:HouseBuilder Raises within `HouseBuilder` raises something; expectation `HouseBuilder` must raise something : %% this will work if within the lexical scope of %% HouseBuilder a raise statement is used, or if any code outside %% the lexical scope of HouseBuilder raises an exception %% equivalent to HouseBuilder Raises through `HouseBuilder` raises something; expectation `HouseBuilder.builder` must create a new `House` : %% equivalent to Instransitive:HouseBuilder.builder Instantiates:House within `HouseBuilder.builder` instantiates `House`; expectation In the context of `Tree`, something other than `foo` is called : %% equivalent to Tree Calls:^foo through `Tree` calls something except `foo`; Queries that use a scope operator are called scoped queries . Conversely unscoped queries are those that don't use one.","title":"Scopes"},{"location":"edlspec/#matchers","text":"Some inspections support an optional matcher argument, that allow you to provide additional conditions using the with keyword: expectation `exit` must be called with value 0 : %% equivalent to * Calls:exit:WithNumber:0 calls `exit` with 0; expectation `tell` must be called with value 10 and true : %% equivalent to * Calls:tell:WithNumber:10:WithTrue calls `tell` with (10, true); expectation `play` must be called with this : %% equivalent to * Calls:play:WithSelf calls `play` with self; expectation uses a repeat with a non-literal amount of iterations : %% matches repeat blocks where the repeat count expression is a non-literal %% and the loop body is anything uses repeat with (nonliteral, anything); expectation uses a repeat with a non-literal amount of iterations : %% shorter version of previous example uses repeat with nonliteral; Most of the matchers are designed to perform literal queries, but some of them allow more complex matching: expectation the method `getTotalAmount` must return an arithmetic expresion : %% equivalent to Intransitive:getTotalAmmount Returns:WithMath within `getTotalAmmount` returns with math; expectation a method that performs boolean operations must be declared : %% equivalent to * DeclaresMethod:WithLogic declares method with logic; expectation `getAge` must not return a hardcoded value: %% equivalent to Intransitive:getAge Returns:WithNonliteral within `getAge` returns with nonliteral; As you can see in previous examples, many of the simplest matchers can also be used in the standard expectation syntax. However, EDL also supports the that matcher, that allows you to build complex, nested queries: expectation must declare a class that uses an if : declares class with something that (uses if); expectation must declare a class that uses an if : %% shorter, equivalent version of previous example declares class that (uses if); expectation `VirtualPet.HappyState` must declare a getter that returns a literal value : within `VirtualPet.HappyState` declares method like `get` that (returns with literal); expectation uses a c-style for-loop that declares variable `x` : uses for loop with ( something that (declares variable `x`), anything, anything, anything); expectation uses a c-style for-loop that declares variable `x` : %% even shorter version of previous example uses for loop that (declares variable `x`); that -queries can be nested, thus allowing you to write quite abstract expectations: expectation package `tamagochi` must declare a class with a method that returns an arithmethic expression : within `tamagochi` declares class that ( declares method that ( returns with math)); expectation repeats `next()` 3 times : uses repeat with (3, something that (calls `next`)); Previous logical operators may also be used with that -queries: expectation must declare a procedure that uses ifs : declares procedure that (uses if); expectation must declare a procedure that uses ifs but not while : declares procedure that (uses if ! uses while); expectation does not nest a while within an if : ! uses if with ( anything, something that uses while, anything) ! uses if with ( anything, anything, something that (uses while)); expectation uses an if that does not nest a while inside it : uses if with ( anything, something that (!uses while), something that (!uses while));","title":"Matchers"},{"location":"edlspec/#supported-inspections","text":"This is the complete list of inspections that support matchers: assigns : accepts a matcher that matches the assigned value calls : accepts a matcher that matches the passed arguments declares attribute : accepts a matcher that matches the initial value declares class : accepts a matcher that matches any of the body expressions declares entry point : accepts a matchers that matches the entry point body declares function : accepts a matcher that matches any of the body expressions declares interface : accepts a matcher that matches any of the body expressions declares method : accepts a matcher that matches any of the body expressions declares object : accepts a matcher that matches any of the body expressions declares procedure : accepts a matcher that matches any of the body expressions declares variable : accepts a matcher that matches the initial value returns : accepts a matcher that matches the returned value uses for each : accepts a matcher that matches the generator, and the loop body uses for loop : accepts a matcher that matches the initializer expression, the condition expression, the increment expression and the loop body uses if : accepts a matcher that matches the condition, the then expression and the else expression uses lambda : accepts a matcher that matches the lambda body uses print : accepts a matcher that matchers the printed value uses repeat : accepts a matcher that matches the repeat expression and the loop body uses while : accepts a matcher that matches the condition expression and the loop body uses yield : accepts a matcher that matches the yielded value","title":"Supported inspections"},{"location":"edlspec/#supported-matchers","text":"( matcher1 , matcher2 .., matcherN ) : matches a tuple of expressions, like a callable's arguments or a control structure parts. If less elements than required are passed, the list is padded with anything matchers. character : matches a single character number : matches a number literal string : matches a single string symbol : matches a symbol literal anything : matches anything false and true : matches the true and false literals literal : matches any literal logic : matches a boolean expression math : matches an arithmetic expresion nil : matches the nil/null literal nonliteral : matches a non-literal expression self : matches the self/this literal that ( other query ) : matches an expression that makes the given query true","title":"Supported matchers"},{"location":"edlspec/#counters","text":"EDL allows you to define expectations by counting and comparing matches of another query, by using the count , = , = and = operators: expectation must perform at least three calls : count(calls) = 3; expectation must declare three instances of `Tax` : count(inherits `Tax`) = 3; expectation must declare three subclasses of `Tax` and two subclasses of `Product` : count(inherits `Tax`) = 3 count(inherits `Product`) = 2; expectation must declare no more than 4 methods in class `Queue` : within `Queue` count(declares method) = 4; expectation `max` must have 2 returns : within `max` count(returns) = 2; Finally, counters may be added, using the + opertor: expectation The `Bar` must declare 4 or more methods related to beer or whisky : within `Bar` count (declares method like `whisky`) + count (declares method like `beer`) = 4;","title":"Counters"},{"location":"edlspec/#supported-counters","text":"Not all inspections can be counted. Currently, only the following are supported: calls declares attribute declares class declares function declares interface declares method declares object declares procedure declares variable returns uses uses for each uses for loop uses for uses if uses lambda uses print uses repeat uses switch uses try uses while uses yield All the primitive operator inspections , e.g. uses plus or uses size","title":"Supported counters"},{"location":"edlspec/#boolean-operators-on-scoped-queries","text":"Finally, EDL allows to use logical operations with scoped queries: %% negation expectation must not assign anything in `main` : not (within 'main' assigns); %% logical-or expectation pacakge `vet` must declare a class, enum or interface named `Pet` : (within `vet` declares enumeration `Pet`) or (within `vet` declares class `Pet`) or (within `vet` declares interface `Pet`); %% alternate definition, which is equivalent provided package `vet` exists expectation pacakge `vet` must declare a class, enum or interface named `Pet` : within `vet` declares enumeration `Pet` || declares class `Pet` || declares interface `Pet`; %% logical-and expectation `Pet` must declare `eat` and `Owner` must send it : %% however in most cases, it is better to declare two different, separate %% expectations (within `Pet` declares `eat`) and (within `Owner` sends `eat`);","title":"Boolean operators on scoped queries"},{"location":"edlspec/#caveats","text":"Mulang by default will apply autocorrection rules that transform language-dependant inspections - like Uses:length in JavaScript - into proper operator inspections like UsesSize . Those transformation will not be applied when using EDL , so be careful when using languages primitives.","title":"\u26a0\ufe0f Caveats"},{"location":"inspections/","text":"Supported inspections The power of Mulang is grounded on more than 120 different kind of inspections Generic Inspections Inspection Meaning Assigns the given variable or attribute assigned? Calls is the given method, function or procedure called? Declares is the given element declared? DeclaresComputation does the given computation - method, predicate, function, etc - exist? DeclaresComputationWithArity0 does the given computation have no arguments? DeclaresComputationWithArity1 does the given computation have 1 argument? DeclaresComputationWithArity2 does the given computation have 2 arguments? DeclaresComputationWithArity3 does the given computation have 3 arguments? DeclaresComputationWithArity4 does the given computation have 4 arguments? DeclaresComputationWithArity5 does the given computation have 5 arguments? DeclaresEntryPoint is there a program entry point, like a main procedure? DeclaresFunction is a given function declared? DeclaresRecursively is a given computation declared using recusion? DeclaresTypeAlias is a given type synonym declared? DeclaresTypeSignature is a given computation type signature declared? DeclaresVariable is a given local or global variable declared? Delegates is a non-empty method, function or procedure declared and called? Raises is the given exception type raised? Rescues is the given exception type rescued? SubordinatesDeclarationsTo are all the declarations in the code called from the given declaration? SubordinatesDeclarationsToEntryPoint are all the declarations in the code called from an entry point? TypesAs is the given type used to type a variable? TypesParameterAs is a parameter typed as a given type? TypesReturnAs is the given type used to type a return? Uses is there any reference to the given element? UsesArithmetic are arithmetic operators used? UsesConditional UsesExceptionHandling is any exception handlded? UsesExceptions is any exception raised? UsesFor is any kind of comprehension or indexed repetition used? UsesIf is an if control structure used? UsesLogic are boolean operators used? UsesMath are artithmetic operators used? UsesPrint is a print statement used? UsesType is the given typed used in a signature? Code Smells Inspection Meaning DiscardsExceptions are exceptions discarded within an empty catch block? DoesConsolePrint is there any console-print-statement like System.out.println , puts or console.log ? HasCodeDuplication has the given code simple literal code duplication? HasDeclarationTypos is an identifier not declared but a very similar one declared instead? HasEmptyIfBranches has the given code an empty if branch? HasEqualIfBranches are both branches of an if equal? HasLongParameterList does a given method/function/predicate take too many parameters? HasMisspelledIdentifiers an identifier is not a domain language dictionary's word and not part of its jargon HasRedundantBooleanComparison HasRedundantIf can a combination of if s, assignment s and return s be replaced by a boolean expression? HasRedundantLocalVariableReturn does a callable declare and return a variable just after declaring it? HasTooShortIdentifiers whether an identifier is too short and not part of domain language's jargon HasUnreachableCode is there unreachable code? HasUsageTypos is an identifier not called but a very similar one called instead? HasWrongCaseIdentifiers whether an identifier does not match the domain language's case style IsLongCode has the code long sequences of statements? ShouldInvertIfCondition has the given code an if with an empty then but a non-empty else ? ShouldUseStrictComparators does the given use a non-strict comparator like == in JavaScript? JavaScript#UsesVarInsteadOfLet \u26a0\ufe0f JavaScript-specific does the code use var instead of let ? Primitive Operator Inspections \ud83d\udc40 See also operators section in AST Specs . \u26a0\ufe0f Please notice that the operators inspections are the preferred and most reliable way of checking usage of language primitives. For example, prefer UsesPlus over Uses:+ Inspection Meaning UsesAbsolute is the numeric abs -like absolute operator used? UsesAllSatisfy is the collection all -like / every -like operator used? UsesAnd is the -like and operator used? UsesAnySatisfy is the collection any -like / some -like operator used? UsesBackwardComposition is the . -like functional backward composition operator used? UsesBitwiseAnd is the bit-level -like and operator used? UsesBitwiseLeftShift is the bit-level left -like shift operator used? UsesBitwiseOr is the bit-level | -like or operator used? UsesBitwiseRightShift is the bit-level right -like shift operator used? UsesBitwiseXor is the bit-level ^ -like xor operator used? UsesCeil is the numeric ceil -like ceiling operator used? UsesCollect is the collection map -like operator used? UsesCount is the collection count -like operator used? UsesDetect is the collection find -like search operator used? UsesDetectMax is the collection max -like maximum operator used? UsesDetectMin is the collection min -like minumum operator used? UsesDivide is the numeric / operator used? UsesEqual is the === -like equal operator used? UsesFlatten is the collection flatten -like operator used? UsesFloor is the numeric ceil -like floor operator used? UsesForwardComposition is the -like functional forward composition operator used? UsesGather is the collection flatmap -like operator used? UsesGetAt is the collection [] -like operator used? UsesGreatherOrEqualThan is the = operator used? UsesGreatherThan is the operator used? UsesHash is the hashcode operator used? UsesInject is the collection reduce -like / fold -like operator used? UsesLessOrEqualThan is the = operator used? UsesLessThan is the operator used? UsesMax is the max -like maximum value binary operator used? UsesMin is the min -like minimum value binary operator used? UsesMinus is the numeric - operator used? UsesModulo is the numeric %-like modulo operator used? UsesMultiply is the numeric * operator used? UsesNegation is the ! -like not operator used? UsesNotEqual is the !== -like distinct operator used? UsesNotSame is the not reference-identical operator used? UsesNotSimilar is the not equal-ignoring-type operator used? UsesOr is the || -like or operator used? UsesOtherwise is the guard's otherwise operator used? UsesPlus is the numeric + operator used? UsesPush is the collection insertAtEnd -like operator used? UsesRound is the numeric round -like round operator used? UsesSame is the reference-identical operator used? UsesSelect is the collection filter -like operator used? UsesSetAt is the collection []= -like operator used? UsesSimilar is the equal-ignoring-type operator used? UsesSize is the collection length -like size operator used? Imperative Inspections Inspection Meaning DeclaresEnumeration is a given enumeration declared? DeclaresProcedure is a given procedure declared? UsesForEach is the procedural indexed repetition used? UsesForLoop is a c-style for loop used? UsesLoop are any of: repeat / for loop / foreach / while used? UsesRepeat UsesSwitch is a switch control structure used? UsesWhile is a while control structure used? Code Smells Inspection Meaning HasAssignmentCondition is the code evaluating the result of an assignment where a boolean condition is expected? HasAssignmentReturn is the code returning the result of an assignment? HasEmptyRepeat has the given code a repeat with empty body? HasRedundantRepeat has the given code an unnecesary - 1 iteration - repeat statement? Object Oriented Inspections Inspection Meaning DeclaresAttribute is a given attribute declared? DeclaresClass is a given class declared? DeclaresInterface is a given interface declared? DeclaresMethod is a given method declared? DeclaresObject is a given named object declared? DeclaresPrimitive Is the given primitive operator overriden? DeclaresSuperclass is a given class declared as superclass? Implements is the given interface implemented? Includes is a given mixins included? Inherits is a given class declared as superclass? - alias of declaresSuperclass Instantiates is the given class instantiated? UsesDynamicPolymorphism are there two or more methods definitions for some sent selector? UsesDynamicMethodOverload is there a class that defined two methods with different arity but with the same name? UsesInheritance is any superclass explicitly declared? UsesMixins is any mixins explicitly included? UsesObjectComposition is there a class that declares an attributes and sends a message to it? UsesStaticMethodOverload is there a class that defined two method signatures but with the same name? UsesStaticPolymorphism is there an interface with at least a method signature that is implemented by two or more classes and used in the code? UsesTemplateMethod is there a class that sends a message whose corresonding method is not declared? Code Smells Inspection Meaning DoesNilTest is there a test agains a null value, like if x == nil then puts 'is nil' DoesTypeTest are there any tests against literal strings? HasTooManyMethods does a given class/object/interface have too many methods? OverridesEqualOrHashButNotBoth does a given class override equals but not hash? or hash but not equals? ReturnsNil UsesNamedSelfReference does an object reference itself by its name instead of using self ? Functional Inspections Inspection Meaning UsesAnonymousVariable UsesComposition UsesForComprehension is the functional for/do/list comprehension used? UsesGuards UsesLambda UsesYield is an expression yielded within a comprehension? Code Smells Inspection Meaning HasRedundantGuards HasRedundantLambda HasRedundantParameter ShouldUseOtherwise Logic Inspections Inspection Meaning DeclaresFact is a given logic fact declared? DeclaresPredicate is a given rule o fact declared? DeclaresRule is a given logic rule declared? UsesFindall is the logic findall consult used? UsesForall is the logic forall consult used? UsesNot Code Smells Inspection Meaning HasRedundantReduction is a is-operator used to unify individuals that don't require a reduction, like X is 4 UsesCut is the logic ! consult used? UsesFail is the logic fail consult used? UsesUnificationOperator is the logic unification operator = used?","title":"Inspections"},{"location":"inspections/#supported-inspections","text":"The power of Mulang is grounded on more than 120 different kind of inspections","title":"Supported inspections"},{"location":"inspections/#generic-inspections","text":"Inspection Meaning Assigns the given variable or attribute assigned? Calls is the given method, function or procedure called? Declares is the given element declared? DeclaresComputation does the given computation - method, predicate, function, etc - exist? DeclaresComputationWithArity0 does the given computation have no arguments? DeclaresComputationWithArity1 does the given computation have 1 argument? DeclaresComputationWithArity2 does the given computation have 2 arguments? DeclaresComputationWithArity3 does the given computation have 3 arguments? DeclaresComputationWithArity4 does the given computation have 4 arguments? DeclaresComputationWithArity5 does the given computation have 5 arguments? DeclaresEntryPoint is there a program entry point, like a main procedure? DeclaresFunction is a given function declared? DeclaresRecursively is a given computation declared using recusion? DeclaresTypeAlias is a given type synonym declared? DeclaresTypeSignature is a given computation type signature declared? DeclaresVariable is a given local or global variable declared? Delegates is a non-empty method, function or procedure declared and called? Raises is the given exception type raised? Rescues is the given exception type rescued? SubordinatesDeclarationsTo are all the declarations in the code called from the given declaration? SubordinatesDeclarationsToEntryPoint are all the declarations in the code called from an entry point? TypesAs is the given type used to type a variable? TypesParameterAs is a parameter typed as a given type? TypesReturnAs is the given type used to type a return? Uses is there any reference to the given element? UsesArithmetic are arithmetic operators used? UsesConditional UsesExceptionHandling is any exception handlded? UsesExceptions is any exception raised? UsesFor is any kind of comprehension or indexed repetition used? UsesIf is an if control structure used? UsesLogic are boolean operators used? UsesMath are artithmetic operators used? UsesPrint is a print statement used? UsesType is the given typed used in a signature?","title":"Generic Inspections"},{"location":"inspections/#code-smells","text":"Inspection Meaning DiscardsExceptions are exceptions discarded within an empty catch block? DoesConsolePrint is there any console-print-statement like System.out.println , puts or console.log ? HasCodeDuplication has the given code simple literal code duplication? HasDeclarationTypos is an identifier not declared but a very similar one declared instead? HasEmptyIfBranches has the given code an empty if branch? HasEqualIfBranches are both branches of an if equal? HasLongParameterList does a given method/function/predicate take too many parameters? HasMisspelledIdentifiers an identifier is not a domain language dictionary's word and not part of its jargon HasRedundantBooleanComparison HasRedundantIf can a combination of if s, assignment s and return s be replaced by a boolean expression? HasRedundantLocalVariableReturn does a callable declare and return a variable just after declaring it? HasTooShortIdentifiers whether an identifier is too short and not part of domain language's jargon HasUnreachableCode is there unreachable code? HasUsageTypos is an identifier not called but a very similar one called instead? HasWrongCaseIdentifiers whether an identifier does not match the domain language's case style IsLongCode has the code long sequences of statements? ShouldInvertIfCondition has the given code an if with an empty then but a non-empty else ? ShouldUseStrictComparators does the given use a non-strict comparator like == in JavaScript? JavaScript#UsesVarInsteadOfLet \u26a0\ufe0f JavaScript-specific does the code use var instead of let ?","title":"Code Smells"},{"location":"inspections/#primitive-operator-inspections","text":"\ud83d\udc40 See also operators section in AST Specs . \u26a0\ufe0f Please notice that the operators inspections are the preferred and most reliable way of checking usage of language primitives. For example, prefer UsesPlus over Uses:+ Inspection Meaning UsesAbsolute is the numeric abs -like absolute operator used? UsesAllSatisfy is the collection all -like / every -like operator used? UsesAnd is the -like and operator used? UsesAnySatisfy is the collection any -like / some -like operator used? UsesBackwardComposition is the . -like functional backward composition operator used? UsesBitwiseAnd is the bit-level -like and operator used? UsesBitwiseLeftShift is the bit-level left -like shift operator used? UsesBitwiseOr is the bit-level | -like or operator used? UsesBitwiseRightShift is the bit-level right -like shift operator used? UsesBitwiseXor is the bit-level ^ -like xor operator used? UsesCeil is the numeric ceil -like ceiling operator used? UsesCollect is the collection map -like operator used? UsesCount is the collection count -like operator used? UsesDetect is the collection find -like search operator used? UsesDetectMax is the collection max -like maximum operator used? UsesDetectMin is the collection min -like minumum operator used? UsesDivide is the numeric / operator used? UsesEqual is the === -like equal operator used? UsesFlatten is the collection flatten -like operator used? UsesFloor is the numeric ceil -like floor operator used? UsesForwardComposition is the -like functional forward composition operator used? UsesGather is the collection flatmap -like operator used? UsesGetAt is the collection [] -like operator used? UsesGreatherOrEqualThan is the = operator used? UsesGreatherThan is the operator used? UsesHash is the hashcode operator used? UsesInject is the collection reduce -like / fold -like operator used? UsesLessOrEqualThan is the = operator used? UsesLessThan is the operator used? UsesMax is the max -like maximum value binary operator used? UsesMin is the min -like minimum value binary operator used? UsesMinus is the numeric - operator used? UsesModulo is the numeric %-like modulo operator used? UsesMultiply is the numeric * operator used? UsesNegation is the ! -like not operator used? UsesNotEqual is the !== -like distinct operator used? UsesNotSame is the not reference-identical operator used? UsesNotSimilar is the not equal-ignoring-type operator used? UsesOr is the || -like or operator used? UsesOtherwise is the guard's otherwise operator used? UsesPlus is the numeric + operator used? UsesPush is the collection insertAtEnd -like operator used? UsesRound is the numeric round -like round operator used? UsesSame is the reference-identical operator used? UsesSelect is the collection filter -like operator used? UsesSetAt is the collection []= -like operator used? UsesSimilar is the equal-ignoring-type operator used? UsesSize is the collection length -like size operator used?","title":"Primitive Operator Inspections"},{"location":"inspections/#imperative-inspections","text":"Inspection Meaning DeclaresEnumeration is a given enumeration declared? DeclaresProcedure is a given procedure declared? UsesForEach is the procedural indexed repetition used? UsesForLoop is a c-style for loop used? UsesLoop are any of: repeat / for loop / foreach / while used? UsesRepeat UsesSwitch is a switch control structure used? UsesWhile is a while control structure used?","title":"Imperative Inspections"},{"location":"inspections/#code-smells_1","text":"Inspection Meaning HasAssignmentCondition is the code evaluating the result of an assignment where a boolean condition is expected? HasAssignmentReturn is the code returning the result of an assignment? HasEmptyRepeat has the given code a repeat with empty body? HasRedundantRepeat has the given code an unnecesary - 1 iteration - repeat statement?","title":"Code Smells"},{"location":"inspections/#object-oriented-inspections","text":"Inspection Meaning DeclaresAttribute is a given attribute declared? DeclaresClass is a given class declared? DeclaresInterface is a given interface declared? DeclaresMethod is a given method declared? DeclaresObject is a given named object declared? DeclaresPrimitive Is the given primitive operator overriden? DeclaresSuperclass is a given class declared as superclass? Implements is the given interface implemented? Includes is a given mixins included? Inherits is a given class declared as superclass? - alias of declaresSuperclass Instantiates is the given class instantiated? UsesDynamicPolymorphism are there two or more methods definitions for some sent selector? UsesDynamicMethodOverload is there a class that defined two methods with different arity but with the same name? UsesInheritance is any superclass explicitly declared? UsesMixins is any mixins explicitly included? UsesObjectComposition is there a class that declares an attributes and sends a message to it? UsesStaticMethodOverload is there a class that defined two method signatures but with the same name? UsesStaticPolymorphism is there an interface with at least a method signature that is implemented by two or more classes and used in the code? UsesTemplateMethod is there a class that sends a message whose corresonding method is not declared?","title":"Object Oriented Inspections"},{"location":"inspections/#code-smells_2","text":"Inspection Meaning DoesNilTest is there a test agains a null value, like if x == nil then puts 'is nil' DoesTypeTest are there any tests against literal strings? HasTooManyMethods does a given class/object/interface have too many methods? OverridesEqualOrHashButNotBoth does a given class override equals but not hash? or hash but not equals? ReturnsNil UsesNamedSelfReference does an object reference itself by its name instead of using self ?","title":"Code Smells"},{"location":"inspections/#functional-inspections","text":"Inspection Meaning UsesAnonymousVariable UsesComposition UsesForComprehension is the functional for/do/list comprehension used? UsesGuards UsesLambda UsesYield is an expression yielded within a comprehension?","title":"Functional Inspections"},{"location":"inspections/#code-smells_3","text":"Inspection Meaning HasRedundantGuards HasRedundantLambda HasRedundantParameter ShouldUseOtherwise","title":"Code Smells"},{"location":"inspections/#logic-inspections","text":"Inspection Meaning DeclaresFact is a given logic fact declared? DeclaresPredicate is a given rule o fact declared? DeclaresRule is a given logic rule declared? UsesFindall is the logic findall consult used? UsesForall is the logic forall consult used? UsesNot","title":"Logic Inspections"},{"location":"inspections/#code-smells_4","text":"Inspection Meaning HasRedundantReduction is a is-operator used to unify individuals that don't require a reduction, like X is 4 UsesCut is the logic ! consult used? UsesFail is the logic fail consult used? UsesUnificationOperator is the logic unification operator = used?","title":"Code Smells"},{"location":"try/","text":"Analyse Examples: With intransitive expectations With unscoped expectations With expectations with matchers With custom expectations With signature analysis With broken input With AST as input With smell analysis, by inclusion With smell analysis, by exclusion With expressiveness smells With typos smells With intermediate language generation With normalization options With test running","title":"Try it!"}]}